<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Тестирование с помощью Foundry</title>
  <link rel="stylesheet" href="./styles.css">
</head>

<body>
  <nav id="navbar">
    <header>Тестирование с помощью Foundry</header>
    <ul>
      <li>
        <a class="nav-link" href="#normal-test">Обычное тестирование</a>
      </li>
    </ul>
  </nav>
  <main id="main-doc">
    <section class="main-section" id="normal-test">
      <article>
        <header>Обычное тестирование</header>
        <h2>Стандартная библиотека Forge</h2>
        <p>Стандартная библиотека Forge (Forge Std) предоставляет богатый набор вспомогательных контрактов для
          фреймворка Foundry, призванных упростить и ускорить процесс написания тестов смарт-контрактов и улучшить
          пользовательский опыт. Используя Forge Std, разработчики могут писать тестовый код более эффективно и удобно.
        </p>
        <h3>Использование Forge Std</h3>
        <p>Тестовый контракт (Test.sol) — это ядро ​​Forge Std, которое не только включает в себя все функции
          DSTest, но и расширяет возможности такие, как стандартная библиотека, экземпляры чит-кодов (vm) и консоль
          Hardhat. Чтобы начать использовать Forge Std, просто импортируйте Test.sol и унаследуйте Test в вашем
          тестовом контракте.</p>
        <code><pre>import "forge-std/Test.sol";

contract ContractTest is Test {
    // Тестовый код
}</pre></code>
        <h3>Основные характеристики</h3>
        <ul>
          <li>Доступ к HEVM: моделируйте различные состояния и поведение блокчейна напрямую с помощью чит-кодов через
            экземпляр виртуальной машины.
            <p class="note-box">HEVM — это реализация виртуальной машины Ethereum (EVM), разработанная командой DappHub,
              специально предназначенная для тестирования и отладки смарт-контрактов. Это инструмент командной строки,
              который может имитировать поведение сети Ethereum, позволяя разработчикам локально выполнять, тестировать
              и отлаживать смарт-контракты без подключения к реальной сети Ethereum.</p>
          </li>
          <li>Утверждения и ведение журнала: унаследовано от Dappsys Test, включает в себя функции утверждений и
            ведение журнала в стиле Hardhat.</li>
          <li>Стандартные функции библиотеки : Стандартная библиотека, предоставляемая Forge Std, включает в себя
            различные служебные инструменты и функции, такие как отправка токенов на указанные учетные записи.</li>
        </ul>
        <h3>Индивидуальный импорт</h3>
        <p>Если вам нужны только определенные функции из интерфейса Vm или библиотеки консоли, вы можете импортировать
          их отдельно:</p>
        <code><pre>import "forge-std/Vm.sol";
import "forge-std/console.sol";
// Or use console2.sol. It provides console.sol patch
// import "forge-std/console2.sol";</pre></code>
        <h3>Стандартная библиотека Forge Std</h3>
        <p>Forge Std объединяет шесть основных стандартных библиотек, каждая из которых предоставляет специализированные
          функции для различных нужд.</p>
        <ul>
          <li>Стандартное журналирование: Std Logs расширяет функциональность регистрации событий на основе библиотеки
            DSTest, предлагая более широкие возможности ведения журнала.</li>
          <li>Стандартные утверждения: Std Assertions расширяет функции утверждений из библиотеки DSTest, улучшая
            возможности утверждений.</li>
          <li>Стандартные читы: Std Cheats предоставляет безопасную оболочку для чит-кодов Forge, упрощая процесс
            разработки. Вызывая их в тестовом контракте, можно легко выполнять такие операции, как подмена личности и
            изменение баланса счёта.</li>
          <li>Стандартные ошибки: Std Errors инкапсулирует распространённые ошибки и откаты Solidity. В сочетании с
            чит-кодом expectRevert нет необходимости запоминать коды паники в Solidity.</li>
          <li>Стандартное хранилище: Std Storage упрощает операции по хранению контрактов, позволяя легко находить и
            изменять место хранения определенных переменных.</li>
          <li>Стандартная математика: Библиотека Std Math предоставляет полезные математические функции, отсутствующие в
            Solidity, предлагая разработчикам больше поддержки математических операций.</li>
        </ul>
        <h3>Резюме</h3>
        <p>Предоставляя ряд практичных инструментов и функций для тестирования, библиотека Forge Standard Library
          значительно повышает эффективность и удобство разработки смарт-контрактов. Forge Std обеспечивает надежную
          поддержку как для базовых утверждений, так и для логирования, а также для более продвинутого моделирования
          состояния блокчейна и обработки ошибок. С помощью этой библиотеки разработчики могут сосредоточиться на логике
          своих смарт-контрактов, а не на утомительной настройке, связанной с процессом тестирования.</p>
        <h2>Чит-коды</h2>
        <p>В процессе разработки смарт-контрактов простого тестирования выходных данных контракта часто недостаточно.
          Также необходима возможность манипулировать состоянием блокчейна, тестировать конкретные операции отката и
          события. Foundry предоставляет разработчикам эту возможность с помощью чит-кодов, делая тестирование более
          полным и точным.</p>
        <p>Чит-коды позволяют разработчикам выполнять ряд нестандартных операций, таких как изменение номеров блоков или
          идентичности вызывающего. Эти функции реализуются путём вызова определённых функций по определённому адресу
          (0x7109709ECfa91a80626fF3989D68f67F5b1DD12D). В контракте Test стандартной библиотеки Forge доступ к чит-кодам
          осуществляется через экземпляр виртуальной машины.</p>
        <h3>Переключение идентичности: vm.prank</h3>
        <p>При проведении тестов, связанных с разрешениями, часто возникает необходимость имитировать поведение разных
          пользователей. С помощью функции vm.prank мы можем временно изменить идентичность вызывающего. Например, при
          тестировании функции, вызов которой разрешён только владельцу контракта, мы можем использовать vm.prank для
          имитации попытки вызова от лица, не являющегося владельцем.</p>
        <code><pre>pragma solidity 0.8.10;

import "forge-std/Test.sol";

contract OwnerUpOnlyTest is Test {
    OwnerUpOnly upOnly;

    function setUp() public {
        upOnly = new OwnerUpOnly();
    }

    function testFail_IncrementAsNotOwner() public {
        vm.prank(address(0));
        upOnly.increment();
    }
}</pre></code>
        <h3>Ожидание отката: vm.expectRevert</h3>
        <p>Проверка корректности отката контракта при определённых условиях является важной частью проверки
          безопасности контракта. vm.expectRevert позволяет указать конкретный тип ошибки или сообщение об ошибке,
          а затем выполнить операцию, которая может вызвать эту ошибку. Если откат контракта происходит ожидаемым
          образом, тест пройден.</p>
        <code><pre>contract OwnerUpOnlyTest is Test {
    OwnerUpOnly upOnly;

    // ...

    function test_RevertWhen_CallerIsNotOwner() public {
        vm.expectRevert(Unauthorized.selector);
        vm.prank(address(0));
        upOnly.increment();
    }
}</pre></code>
        <h3>Ожидание события: vm.expectEmit</h3>
        <p>События в смарт-контрактах позволяют записывать информацию в блокчейн. Проверка корректности запуска
          конкретных событий и соответствия их параметров ожиданиям критически важна для обеспечения корректности
          поведения контракта в тестах. vm.expectEmit позволяет заранее указать ожидаемые характеристики событий и
          проверяет, запускаются ли соответствующие события в операциях контракта.</p>
        <code><pre>contract EmitContractTest is Test {
    event Transfer(address indexed from, address indexed to, uint256 amount);

    function test_ExpectEmit() public {
        ExpectEmit emitter = new ExpectEmit();
        vm.expectEmit(true, true, false, true);
        emit Transfer(address(this), address(1337), 1337);
        emitter.t();
    }
}</pre></code>
        <h3>Резюме</h3>
        <p>Чит-коды предоставляют Foundry мощные возможности тестирования, позволяя разработчикам моделировать сложные
          блокчейн-среды и операции при тестировании смарт-контрактов. Используя такие чит-коды, как переключение
          идентифичности, ожидаение отката и ожидание события, разработчики могут проводить более глубокое и точное
          тестирование смарт-контрактов, гарантируя их надежность и безопасность.</p>
        <h2>Написание тестов</h2>
        <p>Тестирование — важнейший этап обеспечения безопасности и функциональности смарт-контрактов в процессе
          разработки. Использование стандартной библиотеки Forge из набора инструментов Foundry для тестирования может
          значительно упростить и ускорить этот процесс. В этом руководстве мы рассмотрим, как писать тесты с
          использованием тестового контракта Forge, включая базовое тестирование, расширенные функции и использование
          общих настроек.</p>
        <h3>Введение в тестирование с помощью Foundry</h3>
        <p>Foundry предоставляет мощные возможности для тестирования смарт-контрактов Ethereum. Используя тестовый
          контракт в стандартной библиотеке Forge, разработчики могут использовать ряд расширенных функций и чит-кодов
          для моделирования различных состояний блокчейна и поведения транзакций.</p>
        <h3>Базовое использование</h3>
        <p>Сначала импортируйте библиотеку forge-std/Test.sol и сделайте так, чтобы контракт тестирования наследовал от
          Test:</p>
        <code><pre>pragma solidity 0.8.10;

import "forge-std/Test.sol";

contract MyTest is Test {
    // Тестовый код
}</pre></code>
        <p>Таким образом, тестовый контракт может получить доступ к методам утверждения, функциям журналирования,
          чит-кодам и другим функциям, предоставляемым контрактом Test.</p>
        <h3>Ключевые слова тестирования</h3>
        <ul>
          <li>Функция setUp — необязательная функция, которая вызывается перед запуском тестового случая и используется
            для инициализации среды тестирования:</li>
          <code><pre>function setUp() public {
    // Код инициализации
}</pre></code>
          <li>Тестовый случай — функция с префиксом test, — распознанается как тестовый случай и выполняется:</li>
          <code><pre>function test_MyFunctionality() public {
    // Логика тестирования
}</pre></code>
          <li>Функция testFail — В отличие от префикса test, testFail используется для обозначения ожидаемого провала
            теста. Если эта функция не запускает откат, тест считается проваленным:</li>
          <code><pre>function testFail_MyFailingCase() public {
    // Тестовая логика, которая, как ожидается, потерпит неудачу
}</pre></code>
        </ul>
        <h3>Расширенные методы тестирования</h3>
        <ul>
          <li>Точная обработка ошибок с помощью expectRevert — чит-код expectRevert позволяет предвидеть определенные
            ошибки, повышая точность и читаемость тестов:</li>
          <code><pre>function test_MyRevertCase() public {
    vm.expectRevert(SomeError.selector);
    // Может вызвать ошибку SomeError
}</pre></code>
          <li>Развертыватель контрактов в тестировании — контракты, развернутые в тестах, будут развернуты по
            определенному адресу (например, 0xb4c79daB8f259C7Aee6E5b2Aa729821864227e84), что полезно для тестирования
            определенных разрешений (например, onlyOwner).</li>
          <li>Использование общих настроек — создавая абстрактные контракты и наследуя их в тестовых контрактах, можно
            обмениваться настройками:</li>
          <code><pre>abstract contract SetupHelper {
    // Общие коды настройки
}

contract MyTest is Test, SetupHelper {
    function setUp() public {
        // Общая настройка
    }
}</pre></code>
        </ul>
        <h3>Примечания</h3>
        <ul>
          <li>Тестовые функции должны быть объявлены как external или public.</li>
          <li>Использование общих настроек позволяет избежать повторения одного и того же кода инициализации в каждом
            тестовом контракте, что повышает возможность повторного использования кода и удобство его обслуживания.</li>
        </ul>
        <p>Следуя приведенным выше рекомендациям, разработчики могут эффективно писать и выполнять тесты
          смарт-контрактов с использованием стандартной библиотеки Forge, гарантируя качество и безопасность контрактов.
        </p>
        <h2>Выполнение тестов</h2>
        <h3>Базовый запуск тестов</h3>
        <p>Используя команду forge test мы можем запустить все тесты в проекте. Forge автоматически ищет все тестовые
          контракты в каталоге исходного кода и выполняет функции с префиксом test. По умолчанию тестовые файлы обычно
          размещаются в каталоге test/ и имеют расширение .t.sol.</p>
        <p>Пример вывода выполнения forge test может выглядеть так:</p>
        <code><pre>> forge test
No files changed, compilation skipped

Ran 2 tests for test/Counter.t.sol:CounterTest
[PASS] testFuzz_SetNumber(uint256) (runs: 256, μ: 30474, ~: 31252)
[PASS] test_Increment() (gas: 31225)
Suite result: ok. 2 passed; 0 failed; 0 skipped; finished in 15.15ms (14.74ms CPU time)</pre></code>
        <h3>Выполнение определенных тестов</h3>
        <p>Мы можем запускать определенные тестовые случаи или контракты, следуя критериям фильтрации:</p>
        <code>> forge test --match-contract ComplicatedContractTest --match-test test_Deposit</code>
        <p>Эта команда запустит только тестовую функцию с именем test_Deposit, содержащуюся в тестовом контракте с
          именем ComplicatedContractTest.</p>
        <h3>Использование шаблонов Glob</h3>
        <p>We can also use the --match-path flag to run test files that match specific Glob patterns:</p>
        <code>> forge test --match-path test/ContractB.t.sol</code>
        <h3>Журналирование и трассировка</h3>
        <p>По умолчанию тесты Forge отображают только сводную информацию о тестах. Мы можем управлять объёмом
          отображаемой информации, увеличивая уровень детализации (с помощью флага -v).</p>
        <ul>
          <li>Уровень 2 (vv): отображает журналы, созданные во время тестирования, включая ошибки утверждений,
            показывая ожидаемую и фактическую информацию.</li>
          <li>Уровень 3 (vvv): для неудачных тестов также отображаются трассировки стека.</li>
          <li>Уровень 4 (vvvv): отображает трассировки стека для всех тестов и трассировки установки для неудачных
            тестов.</li>
          <li>Уровень 5 (vvvvv): всегда отображает трассировки стека и трассировки установки.</li>
        </ul>
        <h3>Режим слежения</h3>
        <p>При использовании команды forge test --watch Forge будет повторно запускать тесты по мере внесения изменений
          в файлы.</p>
        <p>По умолчанию перезапускаются только изменённые тестовые файлы. Если нужно перезапускать все тесты после
          каждого изменения, можно использовать команду forge test --watch --run-all.</p>
        <h3>Резюме</h3>
        <p>Инструменты тестирования Forge от Foundry предоставляют разработчикам смарт-контрактов мощную и гибкую среду
          тестирования. Благодаря точной фильтрации тестов, подробному журналированию и трассировке, а также удобному
          режиму слежения, разработчики могут эффективно отлаживать и улучшать код смарт-контрактов. Используя Forge, мы
          можем гарантировать качество и безопасность смарт-контрактов, закладывая прочную основу для разработки
          блокчейн-приложений.</p>
        <h2>Анализ трассировок выполнения тестов</h2>
        <p>При использовании Foundry для тестирования смарт-контрактов понимание и анализ трассировок выполнения тестов
          критически важны для оценки влияния вызовов и взаимодействий контрактов. Цель этого урока — помочь
          разработчикам разобраться в трассировках выполнения тестов, включая их формат, цветовую кодировку и
          интерпретацию информации в трассировках.</p>
        <h3>Формат трассировки выполнения теста</h3>
        <p>Трассировки выполнения тестов Foundry имеют иерархическую структуру, наглядно отображающую цепочку вызовов
          контракта и результаты каждого вызова. Основной формат следующий:</p>
        <code><pre>[&lt;Gas Usage&gt;] &lt;Contract&gt;::&lt;Function&gt;(&lt;Parameters&gt;)
  ├─ [&lt;Gas Usage&gt;] &lt;Contract&gt;::&lt;Function&gt;(&lt;Parameters&gt;)
  │   └─  &lt;Return Value&gt;
  └─  &lt;Return Value&gt;</pre></code>
        <ul>
          <li>&lt;Gas Usage&gt;: общий расход газа за весь вызов функции отображается в квадратных скобках.</li>
          <li>&lt;Contract&gt;::&lt;Function&gt;: имя контракта и имя вызываемой функции.</li>
          <li>&lt;Parameters&gt;: параметры, передаваемые в вызов функции.</li>
          <li>&lt;Return Value&gt;: возвращаемое значение вызова функции.</li>
        </ul>
        <p>Каждая трассировка выполнения может содержать несколько подтрассировок, при этом каждая подтрассировка
          представляет собой вызов контракта и его возвращаемое значение.</p>
        <h3>Цветовое кодирование</h3>
        <p>Если ваш терминал поддерживает цветной дисплей, трассировки выполнения тестов Foundry используют разные цвета
          для различения типов вызовов:</p>
        <ul>
          <li>Зеленый: вызовы, которые не привели к отмене.</li>
          <li>Красный: вызовы, которые привели к отмене.</li>
          <li>Синий: вызовы чит-кодов.</li>
          <li>Голубой: выброшенные журналы.</li>
          <li>Желтый: развертывание контрактов.</li>
        </ul>
        <p>Эти цветовые коды помогают разработчикам быстро идентифицировать ключевую информацию в процессе тестирования.
        </p>
        <h3>Проблемы несоответствия потребления газа</h3>
        <p>Иногда может возникнуть ситуация, когда расход газа вызовом не полностью совпадает с суммой расхода
          газа всеми его подвызовами. Это может произойти из-за дополнительных операций, выполняемых между вызовами,
          таких как арифметические операции и операции чтения/записи данных из хранилища. Например:</p>
        <code><sub>[24661] OwnerUpOnlyTest::testIncrementAsOwner()
  ├─ [2262] OwnerUpOnly::count()
  │   └─   0
  ├─ [20398] OwnerUpOnly::increment()
  │ └─   ()
  ├─ [262] OwnerUpOnly::count()
  │ └─   1
  └─   ()</sub></code>
        <p>В этом примере общий расход газа для вызова testIncrementAsOwner составляет 24661, но сумма расходов газа
          для его подвызовов не равна этому значению. Это расхождение обусловлено дополнительными операциями,
          выполняемыми между подвызовами.</p>
        <h3>Декодированные и недекодированные трассировки выполнения</h3>
        <p>Foundry старается декодировать сигнатуры и значения, когда это возможно. Однако в некоторых случаях, когда
          декодирование невозможно, трассировка отображается в следующем формате:</p>
        <code><pre>[&lt;Gas Usage&gt;] &lt;Address&gt;::&lt;Calldata&gt;
  └─   &lt;Return Data&gt;</pre></code>
        <p>В этом формате &lt;Address&gt; представляет адрес вызываемого контракта, &lt;Calldata&gt; — необработанные
          данные, отправляемые функции, а &lt;Return Data&gt; — необработанные данные, возвращаемые вызовом функции. Это
          обычно происходит, когда сигнатура контракта или функции неизвестна или не зарегистрирована в тестовой среде
          Foundry.</p>
        <h3>Резюме</h3>
        <p>Понимание трассировок выполнения тестов, генерируемых Foundry, критически важно для тестирования и отладки
          смарт-контрактов. Освоив формат трассировок выполнения, цветовую кодировку и информацию о потреблении газа,
          разработчики могут более эффективно анализировать поведение контрактов, выявлять и устранять потенциальные
          проблемы.</p>
        <h2>Тестирование форков</h2>
        <p>Тестирование форков — важный метод тестирования при разработке блокчейнов, особенно смарт-контрактов на
          программируемых блокчейнах, таких как Ethereum. Мы рассмотрим два различных способа тестирования форков с
          помощью инструмента Forge: режим форка и чит-коды форка.</p>
      </article>
    </section>
  </main>