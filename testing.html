<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Тестирование с помощью Foundry</title>
  <link rel="stylesheet" href="./styles.css">
</head>

<body>
  <nav id="navbar">
    <header>Тестирование с помощью Foundry</header>
    <ul>
      <li>
        <a class="nav-link" href="#normal-test">Обычное тестирование</a>
      </li>
      <li>
        <a class="nav-link" href="#fork-testing">Тестирование форков</a>
      </li>
      <li>
        <a class="nav-link" href="#fuzz-testing">Фаззинг-тестирование</a>
      </li>
      <li>
        <a class="nav-link" href="#invariant-testing">Тестирование инвариантности</a>
      </li>
      <li>
        <a class="nav-link" href="#differential-testing">Дифференциальное тестирование</a>
      </li>
    </ul>
  </nav>
  <main id="main-doc">
    <section class="main-section" id="normal-test">
      <article>
        <header>Обычное тестирование</header>
        <h2>Стандартная библиотека Forge</h2>
        <p>Стандартная библиотека Forge (Forge Std) предоставляет богатый набор вспомогательных контрактов для
          фреймворка Foundry, призванных упростить и ускорить процесс написания тестов смарт-контрактов и улучшить
          пользовательский опыт. Используя Forge Std, разработчики могут писать тестовый код более эффективно и удобно.
        </p>
        <h3>Использование Forge Std</h3>
        <p>Тестовый контракт (Test.sol) — это ядро ​​Forge Std, которое не только включает в себя все функции
          DSTest, но и расширяет возможности такие, как стандартная библиотека, экземпляры чит-кодов (vm) и консоль
          Hardhat. Чтобы начать использовать Forge Std, просто импортируйте Test.sol и унаследуйте Test в вашем
          тестовом контракте.</p>
        <code><pre>import "forge-std/Test.sol";

contract ContractTest is Test {
    // Тестовый код
}</pre></code>
        <h3>Основные характеристики</h3>
        <ul>
          <li>Доступ к HEVM: моделируйте различные состояния и поведение блокчейна напрямую с помощью чит-кодов через
            экземпляр виртуальной машины.
            <p class="note-box">HEVM — это реализация виртуальной машины Ethereum (EVM), разработанная командой DappHub,
              специально предназначенная для тестирования и отладки смарт-контрактов. Это инструмент командной строки,
              который может имитировать поведение сети Ethereum, позволяя разработчикам локально выполнять, тестировать
              и отлаживать смарт-контракты без подключения к реальной сети Ethereum.</p>
          </li>
          <li>Утверждения и ведение журнала: унаследовано от Dappsys Test, включает в себя функции утверждений и
            ведение журнала в стиле Hardhat.</li>
          <li>Стандартные функции библиотеки : Стандартная библиотека, предоставляемая Forge Std, включает в себя
            различные служебные инструменты и функции, такие как отправка токенов на указанные учетные записи.</li>
        </ul>
        <h3>Индивидуальный импорт</h3>
        <p>Если вам нужны только определенные функции из интерфейса Vm или библиотеки консоли, вы можете импортировать
          их отдельно:</p>
        <code><pre>import "forge-std/Vm.sol";
import "forge-std/console.sol";
// Or use console2.sol. It provides console.sol patch
// import "forge-std/console2.sol";</pre></code>
        <h3>Стандартная библиотека Forge Std</h3>
        <p>Forge Std объединяет шесть основных стандартных библиотек, каждая из которых предоставляет специализированные
          функции для различных нужд.</p>
        <ul>
          <li>Стандартное журналирование: Std Logs расширяет функциональность регистрации событий на основе библиотеки
            DSTest, предлагая более широкие возможности ведения журнала.</li>
          <li>Стандартные утверждения: Std Assertions расширяет функции утверждений из библиотеки DSTest, улучшая
            возможности утверждений.</li>
          <li>Стандартные читы: Std Cheats предоставляет безопасную оболочку для чит-кодов Forge, упрощая процесс
            разработки. Вызывая их в тестовом контракте, можно легко выполнять такие операции, как подмена личности и
            изменение баланса счёта.</li>
          <li>Стандартные ошибки: Std Errors инкапсулирует распространённые ошибки и откаты Solidity. В сочетании с
            чит-кодом expectRevert нет необходимости запоминать коды паники в Solidity.</li>
          <li>Стандартное хранилище: Std Storage упрощает операции по хранению контрактов, позволяя легко находить и
            изменять место хранения определенных переменных.</li>
          <li>Стандартная математика: Библиотека Std Math предоставляет полезные математические функции, отсутствующие в
            Solidity, предлагая разработчикам больше поддержки математических операций.</li>
        </ul>
        <h3>Резюме</h3>
        <p>Предоставляя ряд практичных инструментов и функций для тестирования, библиотека Forge Standard Library
          значительно повышает эффективность и удобство разработки смарт-контрактов. Forge Std обеспечивает надежную
          поддержку как для базовых утверждений, так и для логирования, а также для более продвинутого моделирования
          состояния блокчейна и обработки ошибок. С помощью этой библиотеки разработчики могут сосредоточиться на логике
          своих смарт-контрактов, а не на утомительной настройке, связанной с процессом тестирования.</p>
        <h2>Чит-коды</h2>
        <p>В процессе разработки смарт-контрактов простого тестирования выходных данных контракта часто недостаточно.
          Также необходима возможность манипулировать состоянием блокчейна, тестировать конкретные операции отката и
          события. Foundry предоставляет разработчикам эту возможность с помощью чит-кодов, делая тестирование более
          полным и точным.</p>
        <p>Чит-коды позволяют разработчикам выполнять ряд нестандартных операций, таких как изменение номеров блоков или
          идентичности вызывающего. Эти функции реализуются путём вызова определённых функций по определённому адресу
          (0x7109709ECfa91a80626fF3989D68f67F5b1DD12D). В контракте Test стандартной библиотеки Forge доступ к чит-кодам
          осуществляется через экземпляр виртуальной машины.</p>
        <h3>Переключение идентичности: vm.prank</h3>
        <p>При проведении тестов, связанных с разрешениями, часто возникает необходимость имитировать поведение разных
          пользователей. С помощью функции vm.prank мы можем временно изменить идентичность вызывающего. Например, при
          тестировании функции, вызов которой разрешён только владельцу контракта, мы можем использовать vm.prank для
          имитации попытки вызова от лица, не являющегося владельцем.</p>
        <code><pre>pragma solidity 0.8.10;

import "forge-std/Test.sol";

contract OwnerUpOnlyTest is Test {
    OwnerUpOnly upOnly;

    function setUp() public {
        upOnly = new OwnerUpOnly();
    }

    function testFail_IncrementAsNotOwner() public {
        vm.prank(address(0));
        upOnly.increment();
    }
}</pre></code>
        <h3>Ожидание отката: vm.expectRevert</h3>
        <p>Проверка корректности отката контракта при определённых условиях является важной частью проверки
          безопасности контракта. vm.expectRevert позволяет указать конкретный тип ошибки или сообщение об ошибке,
          а затем выполнить операцию, которая может вызвать эту ошибку. Если откат контракта происходит ожидаемым
          образом, тест пройден.</p>
        <code><pre>contract OwnerUpOnlyTest is Test {
    OwnerUpOnly upOnly;

    // ...

    function test_RevertWhen_CallerIsNotOwner() public {
        vm.expectRevert(Unauthorized.selector);
        vm.prank(address(0));
        upOnly.increment();
    }
}</pre></code>
        <h3>Ожидание события: vm.expectEmit</h3>
        <p>События в смарт-контрактах позволяют записывать информацию в блокчейн. Проверка корректности запуска
          конкретных событий и соответствия их параметров ожиданиям критически важна для обеспечения корректности
          поведения контракта в тестах. vm.expectEmit позволяет заранее указать ожидаемые характеристики событий и
          проверяет, запускаются ли соответствующие события в операциях контракта.</p>
        <code><pre>contract EmitContractTest is Test {
    event Transfer(address indexed from, address indexed to, uint256 amount);

    function test_ExpectEmit() public {
        ExpectEmit emitter = new ExpectEmit();
        vm.expectEmit(true, true, false, true);
        emit Transfer(address(this), address(1337), 1337);
        emitter.t();
    }
}</pre></code>
        <h3>Резюме</h3>
        <p>Чит-коды предоставляют Foundry мощные возможности тестирования, позволяя разработчикам моделировать сложные
          блокчейн-среды и операции при тестировании смарт-контрактов. Используя такие чит-коды, как переключение
          идентифичности, ожидаение отката и ожидание события, разработчики могут проводить более глубокое и точное
          тестирование смарт-контрактов, гарантируя их надежность и безопасность.</p>
        <h2>Написание тестов</h2>
        <p>Тестирование — важнейший этап обеспечения безопасности и функциональности смарт-контрактов в процессе
          разработки. Использование стандартной библиотеки Forge из набора инструментов Foundry для тестирования может
          значительно упростить и ускорить этот процесс. В этом руководстве мы рассмотрим, как писать тесты с
          использованием тестового контракта Forge, включая базовое тестирование, расширенные функции и использование
          общих настроек.</p>
        <h3>Введение в тестирование с помощью Foundry</h3>
        <p>Foundry предоставляет мощные возможности для тестирования смарт-контрактов Ethereum. Используя тестовый
          контракт в стандартной библиотеке Forge, разработчики могут использовать ряд расширенных функций и чит-кодов
          для моделирования различных состояний блокчейна и поведения транзакций.</p>
        <h3>Базовое использование</h3>
        <p>Сначала импортируйте библиотеку forge-std/Test.sol и сделайте так, чтобы контракт тестирования наследовал от
          Test:</p>
        <code><pre>pragma solidity 0.8.10;

import "forge-std/Test.sol";

contract MyTest is Test {
    // Тестовый код
}</pre></code>
        <p>Таким образом, тестовый контракт может получить доступ к методам утверждения, функциям журналирования,
          чит-кодам и другим функциям, предоставляемым контрактом Test.</p>
        <h3>Ключевые слова тестирования</h3>
        <ul>
          <li>Функция setUp — необязательная функция, которая вызывается перед запуском тестового случая и используется
            для инициализации среды тестирования:</li>
          <code><pre>function setUp() public {
    // Код инициализации
}</pre></code>
          <li>Тестовый случай — функция с префиксом test, — распознанается как тестовый случай и выполняется:</li>
          <code><pre>function test_MyFunctionality() public {
    // Логика тестирования
}</pre></code>
          <li>Функция testFail — В отличие от префикса test, testFail используется для обозначения ожидаемого провала
            теста. Если эта функция не запускает откат, тест считается проваленным:</li>
          <code><pre>function testFail_MyFailingCase() public {
    // Тестовая логика, которая, как ожидается, потерпит неудачу
}</pre></code>
        </ul>
        <h3>Расширенные методы тестирования</h3>
        <ul>
          <li>Точная обработка ошибок с помощью expectRevert — чит-код expectRevert позволяет предвидеть определенные
            ошибки, повышая точность и читаемость тестов:</li>
          <code><pre>function test_MyRevertCase() public {
    vm.expectRevert(SomeError.selector);
    // Может вызвать ошибку SomeError
}</pre></code>
          <li>Развертыватель контрактов в тестировании — контракты, развернутые в тестах, будут развернуты по
            определенному адресу (например, 0xb4c79daB8f259C7Aee6E5b2Aa729821864227e84), что полезно для тестирования
            определенных разрешений (например, onlyOwner).</li>
          <li>Использование общих настроек — создавая абстрактные контракты и наследуя их в тестовых контрактах, можно
            обмениваться настройками:</li>
          <code><pre>abstract contract SetupHelper {
    // Общие коды настройки
}

contract MyTest is Test, SetupHelper {
    function setUp() public {
        // Общая настройка
    }
}</pre></code>
        </ul>
        <h3>Примечания</h3>
        <ul>
          <li>Тестовые функции должны быть объявлены как external или public.</li>
          <li>Использование общих настроек позволяет избежать повторения одного и того же кода инициализации в каждом
            тестовом контракте, что повышает возможность повторного использования кода и удобство его обслуживания.</li>
        </ul>
        <p>Следуя приведенным выше рекомендациям, разработчики могут эффективно писать и выполнять тесты
          смарт-контрактов с использованием стандартной библиотеки Forge, гарантируя качество и безопасность контрактов.
        </p>
        <h2>Выполнение тестов</h2>
        <h3>Базовый запуск тестов</h3>
        <p>Используя команду forge test мы можем запустить все тесты в проекте. Forge автоматически ищет все тестовые
          контракты в каталоге исходного кода и выполняет функции с префиксом test. По умолчанию тестовые файлы обычно
          размещаются в каталоге test/ и имеют расширение .t.sol.</p>
        <p>Пример вывода выполнения forge test может выглядеть так:</p>
        <code><pre>> forge test
No files changed, compilation skipped

Ran 2 tests for test/Counter.t.sol:CounterTest
[PASS] testFuzz_SetNumber(uint256) (runs: 256, μ: 30474, ~: 31252)
[PASS] test_Increment() (gas: 31225)
Suite result: ok. 2 passed; 0 failed; 0 skipped; finished in 15.15ms (14.74ms CPU time)</pre></code>
        <h3>Выполнение определенных тестов</h3>
        <p>Мы можем запускать определенные тестовые случаи или контракты, следуя критериям фильтрации:</p>
        <code>> forge test --match-contract ComplicatedContractTest --match-test test_Deposit</code>
        <p>Эта команда запустит только тестовую функцию с именем test_Deposit, содержащуюся в тестовом контракте с
          именем ComplicatedContractTest.</p>
        <h3>Использование шаблонов поиска</h3>
        <p>Мы также можем использовать флаг --match-path для запуска тестовых файлов, которые соответствуют определенным
          шаблонам поиска:</p>
        <code>> forge test --match-path test/ContractB.t.sol</code>
        <h3>Журналирование и трассировка</h3>
        <p>По умолчанию тесты Forge отображают только сводную информацию о тестах. Мы можем управлять объёмом
          отображаемой информации, увеличивая уровень детализации (с помощью флага -v).</p>
        <ul>
          <li>Уровень 2 (vv): отображает журналы, созданные во время тестирования, включая ошибки утверждений,
            показывая ожидаемую и фактическую информацию.</li>
          <li>Уровень 3 (vvv): для неудачных тестов также отображаются трассировки стека.</li>
          <li>Уровень 4 (vvvv): отображает трассировки стека для всех тестов и трассировки установки для неудачных
            тестов.</li>
          <li>Уровень 5 (vvvvv): всегда отображает трассировки стека и трассировки установки.</li>
        </ul>
        <h3>Режим слежения</h3>
        <p>При использовании команды forge test --watch Forge будет повторно запускать тесты по мере внесения изменений
          в файлы.</p>
        <p>По умолчанию перезапускаются только изменённые тестовые файлы. Если нужно перезапускать все тесты после
          каждого изменения, можно использовать команду forge test --watch --run-all.</p>
        <h3>Резюме</h3>
        <p>Инструменты тестирования Forge от Foundry предоставляют разработчикам смарт-контрактов мощную и гибкую среду
          тестирования. Благодаря точной фильтрации тестов, подробному журналированию и трассировке, а также удобному
          режиму слежения, разработчики могут эффективно отлаживать и улучшать код смарт-контрактов. Используя Forge, мы
          можем гарантировать качество и безопасность смарт-контрактов, закладывая прочную основу для разработки
          блокчейн-приложений.</p>
        <h2>Анализ трассировок выполнения тестов</h2>
        <p>При использовании Foundry для тестирования смарт-контрактов понимание и анализ трассировок выполнения тестов
          критически важны для оценки влияния вызовов и взаимодействий контрактов. Цель этого урока — помочь
          разработчикам разобраться в трассировках выполнения тестов, включая их формат, цветовую кодировку и
          интерпретацию информации в трассировках.</p>
        <h3>Формат трассировки выполнения теста</h3>
        <p>Трассировки выполнения тестов Foundry имеют иерархическую структуру, наглядно отображающую цепочку вызовов
          контракта и результаты каждого вызова. Основной формат следующий:</p>
        <code><pre>[&lt;Gas Usage&gt;] &lt;Contract&gt;::&lt;Function&gt;(&lt;Parameters&gt;)
  ├─ [&lt;Gas Usage&gt;] &lt;Contract&gt;::&lt;Function&gt;(&lt;Parameters&gt;)
  │   └─  &lt;Return Value&gt;
  └─  &lt;Return Value&gt;</pre></code>
        <ul>
          <li>&lt;Gas Usage&gt;: общий расход газа за весь вызов функции отображается в квадратных скобках.</li>
          <li>&lt;Contract&gt;::&lt;Function&gt;: имя контракта и имя вызываемой функции.</li>
          <li>&lt;Parameters&gt;: параметры, передаваемые в вызов функции.</li>
          <li>&lt;Return Value&gt;: возвращаемое значение вызова функции.</li>
        </ul>
        <p>Каждая трассировка выполнения может содержать несколько подтрассировок, при этом каждая подтрассировка
          представляет собой вызов контракта и его возвращаемое значение.</p>
        <h3>Цветовое кодирование</h3>
        <p>Если ваш терминал поддерживает цветной дисплей, трассировки выполнения тестов Foundry используют разные цвета
          для различения типов вызовов:</p>
        <ul>
          <li>Зеленый: вызовы, которые не привели к отмене.</li>
          <li>Красный: вызовы, которые привели к отмене.</li>
          <li>Синий: вызовы чит-кодов.</li>
          <li>Голубой: выброшенные журналы.</li>
          <li>Желтый: развертывание контрактов.</li>
        </ul>
        <p>Эти цветовые коды помогают разработчикам быстро идентифицировать ключевую информацию в процессе тестирования.
        </p>
        <h3>Проблемы несоответствия потребления газа</h3>
        <p>Иногда может возникнуть ситуация, когда расход газа вызовом не полностью совпадает с суммой расхода
          газа всеми его подвызовами. Это может произойти из-за дополнительных операций, выполняемых между вызовами,
          таких как арифметические операции и операции чтения/записи данных из хранилища. Например:</p>
        <code><sub>[24661] OwnerUpOnlyTest::testIncrementAsOwner()
  ├─ [2262] OwnerUpOnly::count()
  │   └─   0
  ├─ [20398] OwnerUpOnly::increment()
  │ └─   ()
  ├─ [262] OwnerUpOnly::count()
  │ └─   1
  └─   ()</sub></code>
        <p>В этом примере общий расход газа для вызова testIncrementAsOwner составляет 24661, но сумма расходов газа
          для его подвызовов не равна этому значению. Это расхождение обусловлено дополнительными операциями,
          выполняемыми между подвызовами.</p>
        <h3>Декодированные и недекодированные трассировки выполнения</h3>
        <p>Foundry старается декодировать сигнатуры и значения, когда это возможно. Однако в некоторых случаях, когда
          декодирование невозможно, трассировка отображается в следующем формате:</p>
        <code><pre>[&lt;Gas Usage&gt;] &lt;Address&gt;::&lt;Calldata&gt;
  └─   &lt;Return Data&gt;</pre></code>
        <p>В этом формате &lt;Address&gt; представляет адрес вызываемого контракта, &lt;Calldata&gt; — необработанные
          данные, отправляемые функции, а &lt;Return Data&gt; — необработанные данные, возвращаемые вызовом функции. Это
          обычно происходит, когда сигнатура контракта или функции неизвестна или не зарегистрирована в тестовой среде
          Foundry.</p>
        <h3>Резюме</h3>
        <p>Понимание трассировок выполнения тестов, генерируемых Foundry, критически важно для тестирования и отладки
          смарт-контрактов. Освоив формат трассировок выполнения, цветовую кодировку и информацию о потреблении газа,
          разработчики могут более эффективно анализировать поведение контрактов, выявлять и устранять потенциальные
          проблемы.</p>
      </article>
    </section>
    <section class="main-section" id="fork-testing">
      <article>

        <header>Тестирование форков</header>
        <p>Тестирование форков — важный метод тестирования при разработке блокчейнов, особенно при разработке
          смарт-контрактов на программируемых блокчейнах, таких как Ethereum. Мы изучим два разных способа проведения
          тестирования форков с помощью инструмента Forge: режим форков и чит-коды форков.</p>
        <h2>Режим форков</h2>
        <p>Режим форка позволяет разработчикам запускать все тесты в форкнутой среде, указав RPC-URL. При использовании
          режима форка RPC-URL можно передать с помощью флага --fork-url, как показано ниже:</p>
        <code>forge test --fork-url &lt;your_rpc_url&gt;</code>
        <p>В режиме форка следующие значения будут отражать состояние цепочки на момент форка:</p>
        <ul>
          <li>block_number</li>
          <li>chain_id</li>
          <li>gas_limit</li>
          <li>gas_price</li>
          <li>block_base_fee_per_gas</li>
          <li>block_timestamp</li>
        </ul>
        <p>Чтобы выполнить форк с определенного блока, можно использовать флаг --fork-block-number:</p>
        <code>forge test --fork-url &lt;your_rpc_url&gt; --fork-block-number 1</code>
        <h3>Кэширование</h3>
        <p>Если указаны оба параметра --fork-url и --fork-block-number, данные для этого блока будут кэшированы для
          будущих тестовых запусков. Кэш находится в ~/.foundry/cache/rpc/&lt;имя цепочки&gt;/&lt;номер блока&gt;. Чтобы
          очистить кэш, можно удалить этот каталог или запустить forge clean (что удаляет все артефакты сборки и
          каталоги кэша).</p>
        <h3>Улучшенная трассировка</h3>
        <p>Forge поддерживает идентификацию контрактов в форк-среде с помощью Etherscan. Вы можете передать ключ API
          Etherscan с флагом --etherscan-api-key:</p>
        <code>forge test --fork-url &lt;your_rpc_url&gt; --etherscan-api-key &lt;your_etherscan_api_key&gt;</code>
        <h2>Чит-коды форков</h2>
        <p>Чит-коды форков позволяют программно входить в режим форков в тестовом коде Solidity. Эта техника позволяет
          разработчикам использовать режим форков для каждого теста и обрабатывать несколько форков в рамках теста. В
          этом уроке подробно описано использование чит-кодов форков, приведены примеры кода, а также рассмотрены
          характеристики разделения и постоянства хранилища.</p>
        <h3>Использование чит-кодов форков</h3>
        <p>В отличие от настройки режима форка с помощью параметров Forge CLI, чит-коды форка позволяют создавать,
          выбирать и управлять несколькими форками непосредственно в тестовом коде Solidity. Каждый форк
          идентифицируется уникальным идентификатором uint256.</p>
        <h3>Изоляция тестовых функций</h3>
        <p>Важно отметить, что все тестовые функции изолированы, то есть каждая тестовая функция запускается в копии
          состояния после setUp и выполняется в своей собственной изолированной EVM. Поэтому форки, созданные во время
          setUp, доступны в тестах.</p>
        <h3>Примеры создания и выбора форков</h3>
        <p>Следующий пример демонстрирует, как создавать и выбирать форки с помощью чит-кодов форков в тестовом
          контракте.</p>
        <h3>Определение идентификаторов форков</h3>
        <code><pre>contract ForkTest is Test {
    uint256 mainnetFork;
    uint256 optimismFork;
}</pre></code>
        <p>В контракте ForkTest мы сначала определяем две переменные mainnetFork и optimismFork для хранения
          идентификаторов форков сети mainnet и Optimism.</p>
        <h3>Создание форка</h3>
        <code><pre>function setUp() public {
    mainnetFork = vm.createFork(MAINNET_RPC_URL);
    optimismFork = vm.createFork(OPTIMISM_RPC_URL);
}</pre></code>
        <h3>Выбор форка</h3>
        <code><pre>function testCanSelectFork() public {
    vm.selectFork(mainnetFork);
    assertEq(vm.activeFork(), mainnetFork);
}</pre></code>
        <p>С помощью метода vm.selectFork мы выбираем и активируем определенную ветвь, а затем проверяем корректность
          текущей активированной ветви с помощью vm.activeFork().</p>
        <h3>Независимость и устойчивость форков</h3>
        <p>Каждый форк работает как независимый EVM с собственным отдельным хранилищем. msg.sender и состояние самого
          тестового контракта сохраняются во всех форках. Другими словами, любые изменения, внесенные во время
          активности форка A, записываются только в хранилище форка A и недоступны при выборе другого форка.</p>
        <h3>Пример создания нового контракта</h3>
        <code><pre>function testCreateContract() public {
    vm.selectFork(mainnetFork);
    SimpleStorageContract simple = new SimpleStorageContract();
    simple.set(100);
    assertEq(simple.value(), 100);
    vm.selectFork(optimismFork);
    // Попытка доступа к simple.value() здесь завершится неудачей, поскольку simple существует только в mainnetFork.
}</pre></code>
        <p>В этом примере показан процесс создания нового контракта на активной ветке. При переходе с одной ветки на
          другую доступ между ветками имеют только те учетные записи и контракты, которые помечены как постоянные.</p>
        <h3>Создание постоянных контрактов</h3>
        <p>При тестировании смарт-контрактов, особенно в разных средах форков блокчейна, концепция постоянных учетных
          записей (или контрактов) становится крайне важной. Постоянные учетные записи позволяют нам создавать и
          изменять состояние в одной среде форка и сохранять это состояние неизменным в другой. Следующий пример кода
          иллюстрирует, как создать постоянный контракт и использовать его в разных средах форков:</p>
        <code><pre>contract SimpleStorageContract {
    uint256 public value;

    function set(uint256 _value) public {
        value = _value;
    }
}

// Тестирование создания постоянных контрактов 
function testCreatePersistentContract() public {
    // Сначала выбираем среду форка
    vm.selectFork(mainnetFork);
    // Развеорачиваеь и инициализируем контракт в выбранной среде
    SimpleStorageContract simple = new SimpleStorageContract();
    simple.set(100);
    // Убеждаемся, что статус контракта установлен правильно
    assertEq(simple.value(), 100);

    // Затем помечаем контракт как постоянный
    vm.makePersistent(address(simple));
    // Убеждаемся, что контракт был правильно помечен как постоянный
    assert(vm.isPersistent(address(simple)));

    // Затем переключаемся на среду другого форка
    vm.selectFork(optimismFork);
    // Убеждаемся, что контракт по-прежнему помечен как постоянный даже в среде нового форка
    assert(vm.isPersistent(address(simple)));

    // Наконец, убеждаемся, что состояние постоянного контракта остается неизменным в среде нового форка
    assertEq(simple.value(), 100);
}</pre></code>
        <p>С помощью метода vm.makePersistent(address) мы помечаем простой контракт как постоянный, гарантируя, что его
          состояние (в данном примере — значение, установленное методом set) остается неизменным в средах разных форков.
          Затем мы проверяем, правильно ли контракт помечен как постоянный, вызывая vm.isPersistent(address). При
          переходе в среду другого форка (например, Optimism fork) мы подтверждаем, что контракт по-прежнему сохраняет
          свое постоянное состояние и сохраненное значение, повторно вызывая vm.isPersistent(address) и
          assertEq(simple.value(), 100).</p>
        <p>Эта возможность особенно важна, поскольку позволяет разработчикам тестировать поведение и взаимодействие
          контрактов в средах нескольких форков без необходимости повторного развертывания или переинициализации
          состояний контрактов, тем самым повышая эффективность и результативность тестирования.
        </p>
      </article>
    </section>
    <section class="main-section" id="fuzz-testing">
      <article>
        <header>Фаззинг-тестирование смарт-контрактов</header>
        <p>Фаззинг-тестирование — это автоматизированный метод тестирования программного обеспечения, который тестирует
          программы, генерируя большие объёмы случайных входных данных. В разработке смарт-контрактов
          фаззинг-тестирование используется для выявления потенциальных уязвимостей и аномального поведения в
          контрактах. В этом уроке мы рассмотрим, как проводить фаззинг-тестирование смарт-контрактов.</p>
        <h2>Настройка среды тестирования</h2>
        <p>Сначала необходимо установить и настроить среду Foundry. Затем создайте проект смарт-контракта Solidity и
          напишите код контракта и тестовые файлы. Например, вот простой контракт Safe, который реализует функции
          депозита и снятия средств:</p>
        <code><pre>pragma solidity 0.8.10;

contract Safe {
    receive() external payable {}

    function withdraw() external {
        payable(msg.sender).transfer(address(this).balance);
    }
}</pre></code>
        <h2>Модульное тестирование и тестирование свойств</h2>
        <h3>Модульное тестирование</h3>
        <p>Модульное тестирование сосредоточено на тестировании конкретных функций в коде. Создавая тестовые случаи, вы
          можете проверить, ведет ли себя код ожидаемым образом в заданных условиях.</p>
        <code><pre>import "forge-std/Test.sol";

contract SafeTest is Test {
    Safe safe;

    function setUp() public {
        safe = new Safe();
    }

    function test_Withdraw() public {
        payable(address(safe)).transfer(1 ether);
        uint256 preBalance = address(this).balance;
        safe.withdraw();
        uint256 postBalance = address(this).balance;
        assertEq(preBalance + 1 ether, postBalance);
    }
}</pre></code>
        <h3>Тестирование свойств</h3>
        <p>В отличие от модульного тестирования, тестирование свойств не проверяет конкретные входные и выходные данные,
          а проверяет общие свойства или поведение. Тестирование свойств включает в себя генерацию большого количества
          случайных входных данных, чтобы убедиться, что код ведет себя ожидаемым образом в различных условиях.</p>
        <h3>Переход к тестированию свойств</h3>
        <p>В Foundry любая тестовая функция с параметрами считается тестом свойств. Измените тестовые функции в
          контракте SafeTest, чтобы представить фаззинг-тестирование.</p>
        <code><pre>function testFuzz_Withdraw(uint256 amount) public {
    payable(address(safe)).transfer(amount);
    uint256 preBalance = address(this).balance;
    safe.withdraw();
    uint256 postBalance = address(this).balance;
    assertEq(preBalance + amount, postBalance);
}</pre></code>
        <h3>Обработка больших значений</h3>
        <p>Во время фаззинг-тестирования могут возникнуть ситуации, когда ввод больших значений приводит к сбоям в
          тестировании. Например, если сумма превышает баланс, принадлежащий контракту, тест завершится сбоем. Чтобы
          решить эту проблему, можно ограничить тип суммы uint96, чтобы гарантировать, что вводимые значения
          находятся в разумном диапазоне.</p>
        <code><pre>function testFuzz_Withdraw(uint96 amount) public {
    // Логика тестирования...
}</pre></code>
        <h3>Исключение особых случаев</h3>
        <p>Используя чит-код vm.assume, вы можете исключить определенные случаи, которые не хотите тестировать.
          Например, если вы не хотите тестировать выводы ниже 0,1 ETH, вы можете написать следующее:</p>
        <code><pre>function testFuzz_Withdraw(uint96 amount) public {
    vm.assume(amount > 0.1 ether);
    // Логика тестирования...
}</pre></code>
        <h3>Интерпретация результатов теста</h3>
        <p>Результаты фаззинг-тестирования предоставляют несколько ключевых сведений:</p>
        <ul>
          <li>runs: количество раз, когда тест был запущен. По умолчанию, фаззинг-тестирование генерирует 256 сценариев;
          </li>
          <li>μ: среднее потребление газа за все запуски фаззинга;</li>
          <li>~ (тильда): среднее потребление газа во всех запусках фаззинга.</li>
        </ul>
        <p>Наблюдая за этими показателями, вы можете лучше понять поведение и производительность контракта при различных
          входных данных.</p>
        <h3>Преимущества фаззинг-тестирования</h3>
        <ul>
          <li>Автоматическое тестирование: благодаря автоматическому созданию тестовых случаев сокращается необходимость
            в ручном написании тестовых случаев, что делает процесс тестирования более эффективным и систематическим;
          </li>
          <li>Широкий охват: благодаря рандомизации входных данных, фаззинг-тестирование позволяет исследовать
            различные варианты поведения контракта, выявляя ошибки, которые могут быть упущены при обычном тестировании;
          </li>
          <li>Высокая гибкость: благодаря поддержке настройки параметров тестирования, таких как количество прогонов и
            типы ввода, фаззинг-тестирование можно настроить в соответствии с ранообразными требованиями.</li>
        </ul>
        <h3>Лучшие практики для фаззинг-тестирования</h3>
        <ul>
          <li>Определите цели тестирования: перед проведением фаззинга важно уточнить, какие атрибуты или поведение вы
            хотите протестировать, чтобы можно было разработать эффективные тестовые случаи.</li>
          <li>Установите разумные диапазоны входных данных: ограничив типы и диапазоны входных данных, можно избежать
            ненужных сбоев тестирования, что повысит целенаправленность и эффективность тестирования.</li>
          <li>Анализ результатов тестирования: тщательно анализируйте результаты фаззинга, обращая внимание не только на
            неудачные тестовые случаи, но и на потенциальные проблемы, которые могут быть скрыты в пройденных тестовых
            случаях.</li>
          <li>Сочетание с другими методами тестирования: Несмотря на то, что фаззинг-тестирование — мощный инструмент,
            оно не может охватить все сценарии тестирования. Сочетание фаззинга с другими методами тестирования, такими
            как модульное и интеграционное, позволяет более полно проверить корректность и безопасность
            смарт-контрактов.</li>
        </ul>
        <h3>Резюме</h3>
        <p>Фаззинг-тестирование — мощный инструмент, помогающий разработчикам выявлять и устранять потенциальные
          уязвимости безопасности при разработке смарт-контрактов. Автоматически генерируя большое количество случайных
          входных данных, Фаззинг-тестирование эффективно охватывает граничные условия и исключительные пути в коде,
          повышая стабильность и безопасность контрактов.</p>
      </article>
    </section>
  </main>
</body>