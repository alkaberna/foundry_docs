<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Foundry по-русски</title>
  <link rel="stylesheet" href="./styles.css">
</head>

<body>
  <nav id="navbar">
    <header>Документация Foundry</header>
    <ul>
      <li>
        <a class="nav-link" href="#introduction">Введение в Foundry</a>
      </li>
      <li>
        <a class="nav-link" href="#installation">Установка Foundry</a>
      </li>
      <li>
        <a class="nav-link" href="#forge-init">forge init: инициализация проекта</a>
      </li>
      <li>
        <a class="nav-link" href="#forge-test">forge test: тестирование</a>
      </li>
      <li>
        <a class="nav-link" href="#forge-create">forge create: развертывание и проверка контрактов</a>
      </li>
      <li>
        <a class="nav-link" href="#forge-verify-contract">forge verify-contract: проверка развернутого контракта</a>
      </li>
      <li>
        <a class="nav-link" href="#forge-script">forge script: развертывание и проверка с помощью скриптов</a>
      </li>
      <li>
        <a class="nav-link" href="#cast-overview">Обзор Cast</a>
      </li>

    </ul>
  </nav>
  <main id="main-doc">
    <section class="main-section" id="introduction">
      <article>
        <header>Введение в Foundry</header>
        <p>
          Foundry — это фреймворк Solidity для сборки, тестирования, фаззинга, отладки и развертывания смарт-контрактов
          на Solidity. Преимущество Foundry заключается в том, что он рассматривает Solidity как полноценный инструмент,
          используя его исключительно для разработки и тестирования. Если вы не очень хорошо знакомы с JavaScript,
          Foundry
          — отличный выбор. Он обеспечивает очень высокую скорость сборки и тестирования.
        </p>
        <p>
          Foundry обладает мощными функциями тестирования. Управление состоянием блокчейна с помощью чит-кодов позволяет
          удобно моделировать различные сценарии. Кроме того, поддерживается фаззинг-тестирование на основе свойств.
        </p>
        <p>
          Foundry написан на языке Rust и включает в себя ряд инструментов для взаимодействия с сетью Ethereum, включая:
        </p>
        <p>
        <ul>
          <li>Forge: для тестирования контрактов;</li>
          <li>Cast: для удобного взаимодействия с контрактами, отправки транзакций и запроса данных в цепочке;</li>
          <li>Anvil: для моделирования приватного узла;</li>
          <li>Chisel: для быстрого, эффективного и интерактивного написания и тестирования контрактов в командной
            строке.
          </li>
        </ul>
        </p>
        <p>
          В следующих главах мы рассмотрим каждый из этих инструментов по отдельности.
        </p>
      </article>
    </section>
    <section class="main-section" id="installation">
      <article>
        <header>Установка Foundry</header>
        <p>
          Foundryup — это установщик инструментария Foundry. Мы используем его для установки Foundry. Сначала выполните
          следующую команду в терминале:
        </p>
        <code>curl -L https://foundry.paradigm.xyz | bash</code>
        <p>
          Это загрузит Foundryup. Следуйте инструкциям, чтобы настроить переменные среды, или откройте новое окно, а
          затем установите Foundry, выполнив команду:
        </p>
        <code>foundryup</code>
        <p>
          После установки инструменты Forge, Cast, Anvil и Chisel будут установлены автоматически. Вы можете проверить
          успешность установки, выполнив следующую команду:
        </p>
        <code>forge --version</code>
        <p>
          Будет отображен номер версии Forge, подтверждающий, был ли Forge успешно установлен в вашей системе.
        </p>
        <p>
          Если вы используете Windows, вам необходимо установить и использовать Git BASH или WSL в качестве командного
          терминала, поскольку Foundryup в настоящее время не поддерживает PowerShell или Cmd.
        </p>
        <h2>Установка VSCode</h2>
        <p>
          Для последующей разработки контрактов, компиляции, тестирования и других операций рекомендуется использовать
          VSCode в качестве IDE. Вы можете скачать и установить VSCode для вашей операционной системы здесь, а также
          установить плагин Solidity.
        </p>
      </article>
    </section>
    <section class="main-section" id="forge-init">
      <article>
        <header>forge init: инициализация проекта</header>
        <p>В этом разделе мы продолжим изучать инструмент командной строки Forge и использовать его для создания,
          компиляции и тестирования проектов контрактов. Сначала используйте следующую команду для создания
          демонстрационного проекта hello_foundry:</p>
        <code><pre>> forge init hello_foundry
Installing forge-std in /Users/user/vsc_workspace/hello_foundry/lib/forge-std (url:
Some("https://github.com/foundry-rs/forge-std"), tag: None)
    Installed forge-std v1.8.1
    Initialized forge project</pre></code>
        <p>Команда init создает каталог проекта и устанавливает библиотеку forge-std. Созданная структура проекта
          Foundry выглядит следующим образом:</p>
        <code><pre>> tree -L 2
.
├── README.md
├── foundry.toml
├── lib
│   └── forge-std
├── script
│   └── Counter.s.sol
├── src
│   └── Counter.sol
└── test
    └── Counter.t.sol

6 directories, 5 files</pre></code>
        <ul>
          <li>src: Каталог смарт-контрактов;</li>
          <li>script: файлы скрипта развертывания;</li>
          <li>lib: Каталог библиотеки зависимостей;</li>
          <li>test: Каталог тестовых случаев смарт-контрактов;</li>
          <li>foundry.toml: Конфигурационный файл для указания сетевых URL-адресов и параметров компиляции.</li>
        </ul>
        <p>Мы открываем этот проект с помощью VSCode.</p>
        <p>Counter.sol — это простой контракт счётчика. Он имеет переменную состояния типа uint256, которую он
          присваивает и увеличивает с помощью функций setNumber и increment.</p>
        <h2>Компиляция и тестирование контракта</h2>
        <p>Вы можете скомпилировать контракт с помощью команды forge build. Если в файле foundry.toml не указана версия
          компилятора Solc, по умолчанию будет использована последняя версия. Скомпилированные файлы (ABI контракта,
          байт-код) будут помещены в папку out.</p>
        <code><pre>> forge build
[⠢] Compiling...
[⠒] Installing Solc version 0.8.25
[⠒] Successfully installed Solc 0.8.25
[⠑] Compiling 27 files with 0.8.25
[⠘] Solc 0.8.25 finished in 1.02s
Compiler run successful!</pre></code>
        <p>Вы можете выполнить тестовые случаи контракта с помощью команды forge test.</p>
        <code><pre>> forge test
[⠒] Compiling...
[⠃] Installing Solc version 0.8.25
[⠰] Successfully installed Solc 0.8.25
No files changed, compilation skipped

Ran 2 tests for test/Counter.t.sol:CounterTest
[PASS] testFuzz_SetNumber(uint256) (runs: 256, μ: 30688, ~: 31310)
[PASS] test_Increment() (gas: 31325)
Suite result: ok. 2 passed; 0 failed; 0 skipped; finished in 20.09ms (15.70ms CPU time)

Ran 1 test suite in 115.23ms (20.09ms CPU time): 2 tests passed, 0 failed, 0 skipped (2 total tests)</pre></code>
      </article>
    </section>
    <section class="main-section" id="forge-test">
      <article>
        <header>forge test: тестирование</header>
        <p>Использовать Foundry для написания тестов очень удобно. Команда forge test выполнит все тестовые случаи из
          тестового пакета и выведет результаты тестов Forge (пройдено или нет), причины ошибок и время выполнения.</p>
        <p>Вот некоторые соглашения, касающиеся тестирования:</p>
        <ul>
          <li>
            Тестовые случаи находятся в тестовом пакете и обычно заканчиваются на **.t.sol;
          </li>
          <li>
            Имена методов тестирования начинаются с test_, за которыми следует правило именования в стиле camelCase;
          </li>
          <li>
            Тесты пишутся путем наследования контракта Test.sol из стандартной библиотеки forge-std.
          </li>
        </ul>
        <h2>Тестирование контрактов</h2>
        <p>Ниже представлен тестовый файл test/Counter.t.sol, использующий контракт Test.sol из стандартной библиотеки.
          Функция setUp используется для инициализации перед тестированием: создания новых контрактов и присвоения
          начальных значений переменным состояния. Функции test_xxx автоматически вызываются Forge для тестирования.
          Функция assertEq используется для проверки того, что изменённые переменные состояния равны ожидаемым
          значениям. Кроме того, существует функция assertNotEq, которая проверяет, что два числа не равны.</p>
        <code><pre>// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import {Test, console} from "forge-std/Test.sol";
import {Counter} from "../src/Counter.sol";

contract CounterTest is Test {
    Counter public counter;

    function setUp() public {
        counter = new Counter();
        counter.setNumber(0);
    }

    function test_Increment() public {
        counter.increment();
        assertEq(counter.number(), 1);
    }

    function testFuzz_SetNumber(uint256 x) public {
        counter.setNumber(x);
        assertEq(counter.number(), x);
    }
}</pre></code>
        <h2>Выполнение тестов</h2>
        <p>Тестовые случаи можно выполнить тремя способами:</p>
        <ul>
          <li>Команда forge test запустит все тестовые случаи из тестового пакета. После выполнения в командной строке
            будут выведены результаты теста Forge (пройдено или нет), причины ошибок и время выполнения.</li>
          <li>Используя команду forge test --match-path test/Counter.t.sol, мы указываем путь к файлу с помощью
            -match-path для запуска тестов;</li>
          <li>Используя команду forge test --match-contract CounterTest --match-test test_Increment, мы указываем имя
            тестового контракта с помощью --match-contract, а --match-test указывает тестовый метод, который необходимо
            вызвать.</li>
        </ul>
        <p>Примечание: после --match-path следует имя файла, а после --match-contract — имя контракта. Поэтому при
          указании параметров внимательно следите за корректностью условий сопоставления.</p>
        <h2>Проверка непрохождения：testFail_xxx</h2>
        <p>В предыдущем разделе мы проверили успешность тестов с помощью функции test_Increment и макроса assertEq.
          Аналогичным образом мы можем проверить непрохождение тестов, то есть запуск операции возврата. Если операция
          возврата запущена, тест, как и ожидалось, проваливается, а если нет, то проваливается сам тест.</p>
        <p>Вы можете использовать testFail_xxx для проверки того, запущена ли операция отката.</p>
        <code><pre>pragma solidity 0.8.10;

import "forge-std/Test.sol";

contract ContractBTest is Test {
    uint256 testNumber;

    function setUp() public {
        testNumber = 42;
    }

    function testFail_Subtract43() public {
        testNumber -= 43;
    }
}</pre></code>
        <p>После выполнения функции testFail_Subtract43 значение testNumber становится отрицательным. Однако uint256 —
          беззнаковый тип, то есть не может принимать отрицательные значения. Следовательно, эта функция завершится
          ошибкой. Используя синтаксис testFail_xxx, мы можем получить ожидаемый результат ошибки, как показано ниже:
        </p>
        <code><pre>> forge test --match-path test/CounterB.t.sol

Compiler run successful!

Ran 1 test for test/CounterB.t.sol:ContractBTest
[PASS] testFail_Subtract43() (gas: 2396)
Suite result: ok. 1 passed; 0 failed; 0 skipped; finished in 5.28ms (424.88µs CPU time)

Ran 1 test suite in 173.19ms (5.28ms CPU time): 1 tests passed, 0 failed, 0 skipped (1 total tests)</pre></code>
        <p>PASS в результате означает, что тест пройден, и показывает количество израсходованного газа, что означает,
          что функция не сработала, как и ожидалось. Помимо использования testFail_xxx, мы также можем добиться той же
          функциональности, комбинируя её с чит-кодами, как показано ниже.</p>
        <h2>Проверка непрохождения：чит-коды</h2>
        <p>Чит-коды позволяют нам моделировать различные сценарии и модели поведения, включая изменение состояний
          контрактов, моделирование различных транзакций, корректировку времени и номеров блоков и т. д. Здесь мы
          используем их для моделирования ситуации возврата с целью проверки ненормальной обработки логики контракта.
        </p>
        <code><pre>function test_CannotSubtract43() public {
    vm.expectRevert(stdError.arithmeticError);
    testNumber -= 43;
}</pre></code>
        <p>С помощью vm.expectRevert(stdError.arithmeticError) мы ожидаем возврата. Это означает, что мы ожидаем, что
          эта операция вычитания вызовет возврат из-за арифметической ошибки. Если тест выполняет операцию вычитания, но
          не запускает возврат, тест считается проваленным; в противном случае он пройден. Результат его выполнения
          следующий:</p>
        <code><pre>> forge test --match-path test/CounterB.t.sol
Compiler run successful!

Ran 2 tests for test/CounterB.t.sol:ContractBTest
[PASS] testFail_Subtract43() (gas: 2396)
[PASS] test_CannotSubtract43() (gas: 5754)

Suite result: ok. 2 passed; 0 failed; 0 skipped; finished in 5.01ms (831.63µs CPU time)

Ran 1 test suite in 165.94ms (5.01ms CPU time): 2 tests passed, 0 failed, 0 skipped (2 total tests)</pre></code>
        <p>Примечание: Тестовые функции должны быть видимы извне или публично. Функции, объявленные как внутренние или
          приватные, не будут обрабатываться Forge, даже если их префикс — test.</p>
        <h2>Журналирование информации</h2>
        <p>Мы также можем вывести результаты значений в тестовых случаях, используя console2.sol (который включает патч
          для console.sol, позволяющий Forge декодировать консольные вызовы для трассировки). Мы можем изменить функцию
          test_CannotSubtract43, включив console2.log, как показано ниже:</p>
        <code><pre>function test_CannotSubtract43() public {
    vm.expectRevert(stdError.arithmeticError);
    console2.log("currentNumber = %d", testNumber);
    testNumber -= 43;
}</pre></code>
        <p>По умолчанию forge test отображает только сводку пройденных и проваленных тестов. Вы можете использовать флаг
          -vv для увеличения уровня ведения журнала, например, отображая «currentNumber» в разделе «Logs».</p>
        <code><pre>> forge test --match-path test/CounterB.t.sol -vv
Compiler run successful!

Ran 2 tests for test/CounterB.t.sol:ContractBTest
[PASS] testFail_Subtract43() (gas: 2402)
[PASS] test_CannotSubtract43() (gas: 9053)
Logs:
currentNumber= 42

Suite result: ok. 2 passed; 0 failed; 0 skipped; finished in 5.70ms (1.30ms CPU time)

Ran 1 test suite in 170.65ms (5.70ms CPU time): 2 tests passed, 0 failed, 0 skipped (2 total tests)</pre></code>
        <p>Forge предлагает 5 уровней тестирования, которые можно задать с помощью -v. Среди них forge test эквивалентен
          forge test -v, который выводит данные о потреблении газа в тестовом методе и суммирует результаты
          тестирования.
        </p>
        <ul>
          <li>Level2(vv): Выводит подробную информацию, такую ​​как журналы, утверждения, ожидаемые результаты и причины
            ошибок;</li>
          <li>Level3(vvv): Выводит трассировки стека для неудачных тестов;</li>
          <li>Level4(vvvv): Помимо трассировок стека для неудачных результатов, выводит все трассировки стека для всех
            тестов;</li>
          <li>Level5(vvvvv): Всегда отображает трассировки стека и трассировки настройки. Также отображает создание
            объектов и подробный анализ каждого шага.
        </ul>
      </article>
    </section>
    <section class="main-section" id="forge-create">
      <article>
        <header>forge create: развертывание и проверка контрактов</header>
        <p>Команда forge create в Forge позволяет развёртывать и проверять контракты в заданной сети. Развёртывание
          можно выполнить полностью с помощью командной строки или с помощью скриптов Solidity. В этом разделе мы
          сначала рассмотрим первый вариант.</p>
        <h2>Подготовка</h2>
        <p>Для развертывания контракта в блокчейне нам понадобится учётная запись с тестовыми монетами и RPC-адрес узла
          блокчейна. Кроме того, для верификации контракта нам понадобится ключ ETHERSCAN_API_KEY обозревателя
          блокчейна. В качестве примера мы используем тестовую сеть Sepolia:</p>
        <p>Кран тестовой монеты: https://www.alchemy.com/faucets/ethereum-sepolia позволяет вам получать 0,5 тестовых
          монет Sepolia ETH в день, используя ваш адрес.</p>
        <p>RPC-адрес: Мы можем использовать RPC узлов, предоставленный Alchemy. После регистрации и создания приложения
          для указанной сети RPC будет автоматически выделен.</p>
        <p>ETHERSCAN_API_KEY: Создайте приложение в обозревателе блокчейна Ethereum, чтобы получить соответствующий
          API-ключ.</p>
        <img src="/images/c6456d84-7551-40ef-a7cb-c157ae852fa9.webp" />
        <h2>Коды контрактов</h2>
        <p>В качестве примера мы развернем контракт ERC20. Этот контракт содержит только один конструктор для указания
          имени токена, идентификатора, точности и информации о первоначальной эмиссии.</p>
        <code><pre>// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

import {ERC20} from "solmate/tokens/ERC20.sol";

contract MyToken is ERC20 {
    constructor(
        string memory name,
        string memory symbol,
        uint8 decimals,
        uint256 initialSupply
    ) ERC20(name, symbol, decimals) {
        _mint(msg.sender, initialSupply);
    }
}</pre></code>
        <p>Контракт MyToken наследует пакет solmate от контракта ERC20, поэтому нам необходимо установить зависимости
          solmate:</p>
        <code>forge install transmissions11/solmate</code>
        <h2>Развертывание и проверка</h2>
        <code>forge create --rpc-url &lt;your_rpc_url&gt; --private-key &lt;your_private_key&gt; --verify src/MyContract.sol:MyContract  --constructor-args &lt;constructor_args&gt;</code>
        <ul>
          <li>
            rpc-url: RPC-адрес узла блокчейна, например, https://eth-sepolia.g.alchemy.com/v2/xxxxxxxxx
          </li>
          <li>
            private-key: закрытый ключ кошелька. Рекомендуется создать кошелёк специально для разработки и тестирования.
          </li>
          <li>
            etherscan-api-key: API KEY TOKEN Blockchain Explorer для проверки контракта.
          </li>
          <li>
            verify: проверка контракта, т.е. открытие исходного кода контракта.
          </li>
          <li>
            :MyContract: фактически развёрнутый контракт. Поскольку в одном файле Solidity разрешено несколько
            контрактов, необходимо указать контракт, предназначенный для развёртывания.
          </li>
          <li>
            constructor-args: параметры конструктора контракта. Если параметры конструктора отсутствуют, этот атрибут
            можно опустить.
          </li>
        </ul>
        <p>После выполнения будет предоставлен хэш транзакции, развернутый контрактный адрес и статус проверки.</p>
        <code><pre>> forge create --rpc-url https://eth-sepolia.g.alchemy.com/v2/xxxxxx \
  --constructor-args "MyToken" "MT" 18 1000000000000000000000 \
  --private-key 0xxxxxxx \
  --etherscan-api-key xxxx \
  --verify
  src/MyToken.sol:MyToken
    
[⠊] Compiling...
No files changed, compilation skipped
Deployer: 0x5CB8896Db7Bf13DE6A6EA362866288e577e4F6C5
Deployed to: 0x9C7DcF024b94d14FFaA04262139f92F3AA837919
Transaction hash: 0x18ac7e8824b1fe19ab79977ec7672f8e8324f621fef01a7c8d971fca152748b8
Starting contract verification...
Waiting for etherscan to detect contract deployment...
Start verifying contract `0x9C7DcF024b94d14FFaA04262139f92F3AA837919` deployed on sepolia

Contract [src/MyToken.sol:MyToken] "0x9C7DcF024b94d14FFaA04262139f92F3AA837919" is already verified. Skipping
verification.</pre></code>
      </article>
    </section>
    <section class="main-section" id="forge-verify-contract">
      <article>
        <header>forge verify-contract: проверка развернутого контракта</header>
        <p>Проверка развёрнутых контрактов более сложная. Для неё требуется ряд данных о развёрнутом контракте:</p>
        <code><pre>forge verify-contract \
  --chain-id 11155111 \
  --num-of-optimizations 1000000 \
  --watch \
  --constructor-args $(cast abi-encode "constructor(string,string,uint256,uint256)" "ForgeUSD" "FUSD" 18 1000000000000000000000) \
  --etherscan-api-key &lt;your_etherscan_api_key&gt; \
  --compiler-version v0.8.10+commit.fc410830 \
  &lt;the_contract_address&gt; \
  src/MyToken.sol:MyToken</pre></code>
        <p>Во-первых, нам нужна основная информация о развёрнутом контракте:</p>
        <ul>
          <li>the_contract_address: адрес развёрнутого контракта;</li>
          <li>&lt;path&gt;:&lt;contractname&gt;: путь к исходному коду контракта и имя контракта. Если файл контракта
            содержит несколько контрактов, необходимо указать конкретный контракт с помощью MyContract;</li>
          <li>your_etherscan_api_key: ключ API браузера блокчейна для проверки контракта.</li>
        </ul>
        <p>Во-вторых, нам нужна информация об окружении при развёртывании контракта:</p>
        <ul>
          <li>constructor-args: параметры конструктора контракта, представленные в формате ABI. Если параметры
            конструктора отсутствуют, этот атрибут можно опустить.</li>
          <li>compiler-version: версия компилятора Solidity, используемая для контракта. Если не указана, она будет
            определена автоматически.</li>
          <li>num-of-optimizations: количество итераций, выполняемых компилятором Solidity во время оптимизации.
            Обратите внимание, что если количество оптимизаций не задано во время проверки, оно по умолчанию равно 0;
            Если же значение не задано при развертывании, по умолчанию используется значение 200. Поэтому для
            обеспечения успешной проверки с настройками компиляции по умолчанию используйте -num-of-optimizations 200.
          </li>
          <li>chain-id: идентификатор тестовой сети; для тестовой сети Sepolia это 11155111.</li>
          <li>watch: используется для запроса результатов проверки.</li>
        </ul>
        <h2>Процесс проверки</h2>
        <p>Выполняем эту команду в каталоге проекта. Адрес развёртывания контракта —
          0x18A5A03d871BFb182e29b5951cf708397E48dB1C. Важно отметить, что код контракта должен быть точно таким же,
          как и при развёртывании. Любое расхождение в скомпилированном байт-коде приведёт к ошибке проверки. Кроме
          того, параметры конструктора также должны оставаться неизменными.</p>
        <code><pre>forge verify-contract \
  --chain-id 11155111 \
  --num-of-optimizations 200 \
  --watch \
  --constructor-args $(cast abi-encode "constructor(string,string,uint256,uint256)" "MyToken" "MT" 18 1000000000000000000000) \
  --etherscan-api-key xxxxxx \
  0x18A5A03d871BFb182e29b5951cf708397E48dB1C \
  src/MyToken.sol:MyToken
Start verifying contract `0x18A5A03d871BFb182e29b5951cf708397E48dB1C` deployed on sepolia

Submitting verification for [src/MyToken.sol:MyToken] 0x18A5A03d871BFb182e29b5951cf708397E48dB1C.
Submitted contract for verification:
Response: `OK`
GUID: `a5gxzjgmwt7cdqwjgr5fzwvq6rvqn7mkxlkbywk9rahyd7gvxe`
URL: https://sepolia.etherscan.io/address/0x18a5a03d871bfb182e29b5951cf708397e48db1c
Contract verification status:
Response: `OK`
Details: `Pass - Verified`
Contract successfully verified</pre></code>
        <p>Примечание: При проверке вы можете столкнуться с ошибкой подключения к Etherscan, о чём свидетельствует
          сообщение об ошибке: «Ошибка при попытке подключения: Сброс соединения удалённым узлом (ошибка ОС 54)». Обычно
          это вызвано проблемами сети, а не ошибкой команды.</p>
      </article>
    </section>
    <section class="main-section" id="forge-script">
      <article>
        <header>forge script: развертывание и проверка с помощью скриптов</header>
        <p>Развёртывание и проверка контрактов с помощью команды forge create требует ввода множества параметров. Более
          рекомендуемый подход — использовать Solidity Scripting. Это метод декларативного развёртывания контрактов с
          использованием Solidity вместо JavaScript.</p>
        <h2>Конфигурации проекта</h2>
        <p>Чтобы развернуть контракт MyToken из предыдущего раздела в тестовой сети Sepolia, необходимо выполнить
          некоторые настройки в проекте Froundry:</p>
        <ol>
          <li>
            Создайте файл .env для хранения конфиденциальной информации, такой как RPC узла и закрытые ключи, в
            следующем формате:
            <code><pre>// Blockchain RPC node address
SEPOLIA_RPC_URL=xxxx
// Private key
PRIVATE_KEY=xxxx
// Blockchain explorer API KEY TOKEN
ETHERSCAN_API_KEY=xxxx</pre></code>
          </li>
          <li>
            Добавьте следующие строки в конец файла foundry.toml, чтобы указать переменные, настроенные в файле .env:
            <code><pre>[rpc_endpoints]
sepolia = "${SEPOLIA_RPC_URL}"

[etherscan]
sepolia = { key = "${ETHERSCAN_API_KEY}" }</pre></code>
          </li>
          <li>
            Создайте тестовый скрипт. Создайте папку с именем script в корневом каталоге проекта, а в ней — файл
            MyToken.s.sol для скрипта развёртывания:
            <code><pre>// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.25;

import {Script} from "forge-std/Script.sol";
import "../src/MyToken.sol";

contract MyTokenScript is Script {

    function run() external {
        uint256 deployer = vm.envUint("PRIVATE_KEY");

        vm.startBroadcast(deployer);

        MyToken myToken = new MyToken("MyToken", "MT", 18, 1000000000000000000);
        vm.stopBroadcast();
    }
}</pre></code>
          </li>
        </ol>
        <p>Этот скрипт развёртывания сам по себе является смарт-контрактом. Как и любой другой смарт-контракт,
          написанный на Solidity, он должен указывать версию прагмы. Он также наследует контракт Script из стандартной
          библиотеки Forge:</p>
        <code>contract MyTokenScript is Script</code>
        <p>По умолчанию скрипты выполняются путём вызова функции run, которая служит точкой входа.</p>
        <code>uint256 deployer = vm.envUint("PRIVATE_KEY");</code>
        <p>Извлекаем закрытый ключ из .env.</p>
        <code>vm.startBroadcast(deployer);</code>
        <p>Выше представлен специальный чит-код для записи вызовов и создания контрактов, выполняемых основным
          контрактом скрипта. Мы передаём развёртыватель (с назначенным ему закрытым ключом) для подписания транзакций.
          Затем мы транслируем эти транзакции для развёртывания нашего контракта MyToken.</p>
        <code>MyToken myToken = new MyToken("MyToken", "MT", 18, 1000000000000000000);</code>
        <p>
          Приведенная выше строка кода создает контракт MyToken и записывается Forge, как указано в
          vm.startBroadcast(), и готова к трансляции в сеть.
        </p>
        <h2>Выполнение развертывания и проверки</h2>
        <p>
          Добавьте ранее упомянутые переменные в файл .env и выполните следующую команду в корневом каталоге проекта:
        </p>
        <code><pre># Load the variables fr the .env file
source .env

# Deploy and verify contract
forge script script/MyToken.s.sol:MyTokenScript --rpc-url $SEPOLIA_RPC_URL --broadcast --verify -vvvv</pre></code>
        <p>Forge запустит скрипт и транслирует транзакцию. Это может занять некоторое время, так как необходимо
          дождаться подтверждения транзакции. Примерно через минуту вы увидите информацию, похожую на представленную
          ниже, включая адрес развёртывания контракта, расход газа, хэш транзакции, результат проверки и т. д.</p>
        <code><pre>> forge script script/MyToken.s.sol:MyTokenScript --rpc-url $SEPOLIA_RPC_URL --broadcast --verify -vvvv

// ...

== Logs ==
MyToken deployed on 0xA4d3C606ad7731e5Aa0CE6D79060E7A74D7DAba0


==========================

Chain 11155111

Estimated gas price: 3.000231466 gwei

Estimated total gas used for script: 968059

Estimated amount required: 0.002904401072744494 ETH

==========================
##
Sending transactions [0 - 0].
⠁ [00:00:00]
[########################################################################################################################]
1/1 txes (0.0s)##
Waiting for receipts.
⠉ [00:00:13]
[####################################################################################################################]
1/1 receipts (0.0s)
##### sepolia
✅ [Success]Hash: 0x3d6150e746d44665ceb845a530222c215c6cdab5ff728c352bd9d3845d73feb0
Contract Address: 0xA4d3C606ad7731e5Aa0CE6D79060E7A74D7DAba0
Block: 5525173
Paid: 0.00223486014132905 ETH (744923 gas * 3.00012235 gwei)



==========================

ONCHAIN EXECUTION COMPLETE & SUCCESSFUL.
Total Paid: 0.00223486014132905 ETH (744923 gas * avg 3.00012235 gwei)
##
Start verification for (1) contracts
Start verifying contract `0xA4d3C606ad7731e5Aa0CE6D79060E7A74D7DAba0` deployed on sepolia

Submitting verification for [src/MyToken.sol:MyToken] 0xA4d3C606ad7731e5Aa0CE6D79060E7A74D7DAba0.
Submitted contract for verification:
Response: `OK`
GUID: `br211fmqfsf5fn7u5c1qj3pbjvsvh6i84zkhr7nru8s39kyuif`
URL: https://sepolia.etherscan.io/address/0xa4d3c606ad7731e5aa0ce6d79060e7a74d7daba0
Contract verification status:
Response: `NOTOK`
Details: `Pending in queue`
Contract verification status:
Response: `OK`
Details: `Pass - Verified`
Contract successfully verified
All (1) contracts were verified!</pre></code>
        <p>Это подтверждает успешное развертывание контракта MyToken в тестовой сети Sepolia, которое было проверено на
          Etherscan. Все было выполнено с помощью одной команды!</p>
      </article>
    </section>
    <section class="main-section" id="cast-overview">
      <article>
        <header>Обзор Cast</header>
        <p>В этом разделе мы изучим Cast и покажем, как его использовать, на двух простых примерах.</p>
        <h2>Что такое Cast?</h2>
        <p>Cast — это инструмент командной строки, используемый Foundry для выполнения RPC-вызовов Ethereum. Cast можно
          использовать для вызова функций смарт-контрактов, отправки транзакций и извлечения любых данных из блокчейна.
        </p>
        <h2>Как использовать Cast?</h2>
        <p>Чтобы использовать Cast, выполните команду cast с последующей подкомандой в командной строке:</p>
        <code>> cast &lt;subcommand&gt;</code>
        <h2>Пример</h2>
        <p>Мы можем использовать cast для получения общего запаса токенов DAI:</p>
        <code>> cast call 0x6b175474e89094c44da98b954eedeac495271d0f "totalSupply()(uint256)" --rpc-url &lt;your-rpc-url&gt; 8603853182003814300330472690</code>
        <p>Результат будет следующим:</p>
        <code>3214023094757495931935215279 [3.214e27]</code>
        <p>Мы можем использовать cast для отправки произвольных сообщений. Ниже приведён пример отправки сообщения между
          двумя учётными записями.</p>
        <code>> cast send --private-key &lt;Your Private Key&gt; 0x3c44cdddb6a900fa2b585dd299e03d12fa4293bc $(cast from-utf8 "hello world") --rpc-url http://127.0.0.1:8545/</code>
        <h2>Получение основной информации о блокчейне с помощью Cast</h2>
        <p>В этом разделе мы извлечём фундаментальную информацию о блокчейне с помощью команд cast. Cast — это мощный
          инструмент командной строки, позволяющий разработчикам взаимодействовать с блокчейном Ethereum, выполняя
          различные запросы и транзакционные задачи. Освоение cast значительно повысит эффективность разработки
          смарт-контрактов. Можете ли вы вспомнить пример использования cast для получения общего запаса токенов DAI?
        </p>
        <code>> cast call 0x6b175474e89094c44da98b954eedeac495271d0f "totalSupply()(uint256)" --rpc-url &lt;your rpc url&gt; 8603853182003814300330472690</code>
        <p>Мы определили URL-адрес Ethereum RPC с помощью свойства --rpc-url; однако мы можем взаимодействовать с
          блокчейном Ethereum, установив переменную среды URL-адреса Ethereum RPC, устраняя необходимость настраивать ее
          каждый раз при запуске команды.</p>
        <code>export ETH_RPC_URL="https://eth-mainnet.alchemyapi.io/v2/Lc7oIGYeL_Qv......."</code>
        <h3>cast chain-id</h3>
        <p>Команда cast chain-id извлекает идентификатор текущего блокчейна, что является ключевым шагом в идентификации
          и подтверждении того, что мы работаем с правильным блокчейном. Например, обеспечение точности идентификатора
          блокчейна крайне важно при развертывании контрактов или проверке транзакций.</p>
        <code><pre>> cast chain-id
1(0x1)</pre></code>
        <h3>cast chain, cast client</h3>
        <p>Чтобы получить имя текущей цепочки, мы можем использовать cast chain, а чтобы получить версию текущего
          клиента, используйте cast client.</p>
        <code><pre>> cast chain
ethlive

> cast client
Geth/v1.13.13-stable-7f131dcb/linux-amd64/go1.21.7</pre></code>
        <h3>cast gas-price</h3>
        <p>Команда cast gas-price предоставляет разработчикам быстрый способ получить текущую цену на газ, что очень
          полезно для оценки транзакционных издержек. Знание текущей цены на газ может помочь разработчикам точнее
          устанавливать лимит газа для транзакций, избегая чрезмерных комиссий за транзакции или сбоев транзакций из-за
          недостатка газа.</p>
        <code><pre>> cast gas-price
10325245432</pre></code>
        <h2>Получение информации о блоке с помощью Cast</h2>
        <p>В этом уроке мы научимся использовать cast для извлечения информации о блоках из блокчейна Ethereum. Эти
          команды — важнейшие инструменты для понимания динамической информации о блоках в блокчейне Ethereum, и их
          освоение поможет разработчикам блокчейнов эффективно анализировать и отслеживать блоки.</p>
        <h3>cast block-number</h3>
        <p>Чтобы запросить номер последнего блока, мы используем команду cast block-number. Это фундаментальная операция
          для отслеживания текущего состояния блокчейна, которая очень полезна для определения последних транзакций и
          статуса активности смарт-контрактов. Пример вывода:</p>
        <code><pre>> cast block-number
19732815</pre></code>
        <h3>cast basefee</h3>
        <p>Команда cast basefee позволяет получить базовую комиссию за указанный блок. После обновления London
          базовая комиссия стала частью комиссий за транзакции, что делает её критически важной для оценки стоимости
          транзакций. Пример:</p>
        <code><pre>> cast basefee
11721855264</pre></code>
        <h3>cast block</h3>
        <p>С помощью команды cast block мы можем получить подробную информацию о заданном блоке, такую ​​как высота
          блока, временная метка, количество транзакций и многое другое. Эта команда — мощный инструмент для более
          глубокого понимания изменений в состоянии блокчейна. Пример:</p>
        <code><pre>> cast block 12345678
{
    "number": "12345678",
    "timestamp": "1618304000",
    "transactions": "210",
    "miner": "0x..."
    ......
}</pre></code>
        <h3>cast age</h3>
        <p>Команда cast age извлекает временную метку указанного блока, указывающую точное время его создания. Это может
          помочь разработчикам отслеживать точное время возникновения событий и анализировать временные ряды данных
          блокчейна. Пример:</p>
        <code><pre>> cast age
Thu Apr 25 13:59:47 2024</pre></code>
        <h2>Получение информацию об учетной записи с помощью Cast</h2>
        <p>В этом уроке мы научимся использовать cast для запроса информации, связанной со счётом. Понимание
          того, как проверять информацию со счёта, имеет основополагающее значение для разработки смарт-контрактов и
          анализа транзакций. Это критически важно для мониторинга потоков средств, проверки транзакций и понимания
          состояний счёта.</p>
        <h3>cast balance</h3>
        <p>Команда cast balance получает текущий баланс (в wei) для конкретного адреса учётной записи Ethereum или имени
          ENS. Эта команда широко используется в повседневных операциях с блокчейном, будь то проверка перед
          развертыванием смарт-контрактов, выполнение транзакций или мониторинг состояния учётной записи.</p>
        <h3>Получение баланса учетной записи</h3>
        <p>Чтобы узнать баланс учетной записи, вам достаточно указать его адрес или имя в ENS. Эта функция невероятно
          полезна, особенно при работе с несколькими счётами или когда вам нужно быстро проверить состояние средств.
          Пример:</p>
        <code>> cast balance 0x123...</code>
        <p>На выходе будет отображен текущий баланс учетной записи на Ethereum, измеренный в wei.</p>
        <h3>Запрос баланса ENS</h3>
        <p>Мы также можем напрямую использовать ENS для запроса баланса, не зная базовый адрес. Это упрощает операции,
          поскольку запоминать или работать со сложными адресами Ethereum неудобно.</p>
        <code>> cast balance vitalik.eth</code>
        <p>На выходе будет отображен текущий баланс ENS на Ethereum.</p>
        <h2>Отправка транзакций с помощью Cast</h2>
        <p>В этом уроке мы научимся использовать cast для отправки транзакций и взаимодействия со смарт-контрактами,
          развёрнутыми в блокчейне Ethereum. Освоение этих навыков критически важно для разработчиков смарт-контрактов,
          поскольку позволяет выполнять функции контрактов, активировать функции отката (fallback) и приема средств
          (receive) контрактов.</p>
        <h3>Вызов функций контракта</h3>
        <p>Имея адрес контракта, вы можете вызывать любую функцию контракта, используя команду cast send с закрытым
          ключом вашей учётной записи. Это предоставляет разработчикам возможность прямого взаимодействия со
          смарт-контрактами, будь то внесение средств, вывод средств или изменение состояния контракта. Пример:</p>
        <code>> cast send --private-key &lt;private_key_addr&gt; &lt;contract_addr&gt; "exampleFunc(uint256)" &lt;argument_value_of_the_function&gt;</code>
        <h3>Пример: Функция депозита</h3>
        <p>Чтобы отправить запрос на депозит по контракту, используйте следующую команду:</p>
        <code>> cast send --private-key 0x123... 0xabc... "deposit(uint256)" 10</code>
        <p>Данная команда отправляет запрос на вызов функции депозита контракта 0xabc..., с суммой депозита 10 wei.</p>
        <h3>Активация функции отката</h3>
        <p>Если мы вызываем функцию, отсутствующую в контракте, автоматически активируется резервная функция. Это можно
          использовать для тестирования обработки исключений контракта или специфических функцииональностей. Пример:</p>
        <code>cast send --private-key &lt;private_key_addr&gt; &lt;contract_addr&gt; "dummy()"</code>
        <h3>Пример: вызов несуществующей функции</h3>
        <p>Вы можете проверить активацию функции отката контракта с помощью следующей команды:</p>
        <code>> cast send --private-key 0x123... 0xabc... "dummy()"</code>
        <h3>Активация функции приема средств</h3>
        <p>Отправка эфира на контракт активирует функцию приема средств контракта. Это полезно для приёма пожертвований
          или обработки платежей. Пример:</p>
        <code>> cast send --private-key &lt;private_key_addr&gt; &lt;contract_addr&gt; --value 10gwei</code>
        <h3>Пример: отправка эфира</h3>
        <p>Следующая команда демонстрирует, как отправить 10 gwei на контракт, запустив функцию приема средств:</p>
        <code>> cast send --private-key 0x123... 0xabc... --value 10gwei</code>
        <h3>Отправка транзакций с помощью Cast</h3>
        <p>В этом уроке мы научимся использовать cast для получения исходного кода смарт-контрактов из Etherscan. Для
          блокчейн-разработчиков критически важно иметь возможность просматривать и понимать исходный код
          ончейн-контрактов. Это помогает анализировать функциональность контрактов и проверять их безопасность.</p>
        <h3>Получкние исходного кода контракта</h3>
        <p>Команда cast etherscan-source позволяет быстро получить исходный код указанного контракта с сайта Etherscan.
          Это мощная функция, позволяющая разработчикам просматривать конкретную реализацию любого контракта, публично
          развёрнутого на Ethereum. Пример:</p>
        <code>> cast etherscan-source &lt;contract_address&gt;</code>
        <h3>Пример: получение кода контракта</h3>
        <p>Если вы хотите просмотреть исходный код определенного контракта, вы можете использовать следующую команду:
        </p>
        <code>> cast etherscan-source 0x123...</code>
        <p>Эта команда отправит запрос Etherscan на извлечение исходного кода смарт-контракта по адресу 0x123... и
          отобразит его.</p>
      </article>
    </section>
  </main>
</body>

</html>