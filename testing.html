<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Тестирование с помощью Foundry</title>
  <link rel="stylesheet" href="./styles.css">
</head>

<body>
  <nav id="navbar">
    <header>Тестирование с помощью Foundry</header>
    <ul>
      <li>
        <a class="nav-link" href="#normal-test">Обычное тестирование</a>
      </li>
      <li>
        <a class="nav-link" href="#fork-testing">Тестирование форков</a>
      </li>
      <li>
        <a class="nav-link" href="#fuzz-testing">Фаззинг-тестирование</a>
      </li>
      <li>
        <a class="nav-link" href="#invariant-testing">Инвариантное тестирование</a>
      </li>
      <li>
        <a class="nav-link" href="#differential-testing">Дифференциальное тестирование</a>
      </li>
    </ul>
  </nav>
  <main id="main-doc">
    <section class="main-section" id="normal-test">
      <article>
        <header>Обычное тестирование</header>
        <h2>Стандартная библиотека Forge</h2>
        <p>Стандартная библиотека Forge (Forge Std) предоставляет богатый набор вспомогательных контрактов для
          фреймворка Foundry, призванных упростить и ускорить процесс написания тестов смарт-контрактов и улучшить
          пользовательский опыт. Используя Forge Std, разработчики могут писать тестовый код более эффективно и удобно.
        </p>
        <h3>Использование Forge Std</h3>
        <p>Тестовый контракт (Test.sol) — это ядро ​​Forge Std, которое не только включает в себя все функции
          DSTest, но и расширяет возможности такие, как стандартная библиотека, экземпляры чит-кодов (vm) и консоль
          Hardhat. Чтобы начать использовать Forge Std, просто импортируйте Test.sol и унаследуйте Test в вашем
          тестовом контракте.</p>
        <code><pre>import "forge-std/Test.sol";

contract ContractTest is Test {
    // Тестовый код
}</pre></code>
        <h3>Основные характеристики</h3>
        <ul>
          <li>Доступ к HEVM: моделируйте различные состояния и поведение блокчейна напрямую с помощью чит-кодов через
            экземпляр виртуальной машины.
            <p class="note-box">HEVM — это реализация виртуальной машины Ethereum (EVM), разработанная командой DappHub,
              специально предназначенная для тестирования и отладки смарт-контрактов. Это инструмент командной строки,
              который может имитировать поведение сети Ethereum, позволяя разработчикам локально выполнять, тестировать
              и отлаживать смарт-контракты без подключения к реальной сети Ethereum.</p>
          </li>
          <li>Утверждения и ведение журнала: унаследовано от Dappsys Test, включает в себя функции утверждений и
            ведение журнала в стиле Hardhat.</li>
          <li>Стандартные функции библиотеки : Стандартная библиотека, предоставляемая Forge Std, включает в себя
            различные служебные инструменты и функции, такие как отправка токенов на указанные учетные записи.</li>
        </ul>
        <h3>Индивидуальный импорт</h3>
        <p>Если вам нужны только определенные функции из интерфейса Vm или библиотеки консоли, вы можете импортировать
          их отдельно:</p>
        <code><pre>import "forge-std/Vm.sol";
import "forge-std/console.sol";
// Or use console2.sol. It provides console.sol patch
// import "forge-std/console2.sol";</pre></code>
        <h3>Стандартная библиотека Forge Std</h3>
        <p>Forge Std объединяет шесть основных стандартных библиотек, каждая из которых предоставляет специализированные
          функции для различных нужд.</p>
        <ul>
          <li>Стандартное журналирование: Std Logs расширяет функциональность регистрации событий на основе библиотеки
            DSTest, предлагая более широкие возможности ведения журнала.</li>
          <li>Стандартные утверждения: Std Assertions расширяет функции утверждений из библиотеки DSTest, улучшая
            возможности утверждений.</li>
          <li>Стандартные читы: Std Cheats предоставляет безопасную оболочку для чит-кодов Forge, упрощая процесс
            разработки. Вызывая их в тестовом контракте, можно легко выполнять такие операции, как подмена личности и
            изменение баланса счёта.</li>
          <li>Стандартные ошибки: Std Errors инкапсулирует распространённые ошибки и откаты Solidity. В сочетании с
            чит-кодом expectRevert нет необходимости запоминать коды паники в Solidity.</li>
          <li>Стандартное хранилище: Std Storage упрощает операции по хранению контрактов, позволяя легко находить и
            изменять место хранения определенных переменных.</li>
          <li>Стандартная математика: Библиотека Std Math предоставляет полезные математические функции, отсутствующие в
            Solidity, предлагая разработчикам больше поддержки математических операций.</li>
        </ul>
        <h3>Резюме</h3>
        <p>Предоставляя ряд практичных инструментов и функций для тестирования, библиотека Forge Standard Library
          значительно повышает эффективность и удобство разработки смарт-контрактов. Forge Std обеспечивает надежную
          поддержку как для базовых утверждений, так и для логирования, а также для более продвинутого моделирования
          состояния блокчейна и обработки ошибок. С помощью этой библиотеки разработчики могут сосредоточиться на логике
          своих смарт-контрактов, а не на утомительной настройке, связанной с процессом тестирования.</p>
        <h2>Чит-коды</h2>
        <p>В процессе разработки смарт-контрактов простого тестирования выходных данных контракта часто недостаточно.
          Также необходима возможность манипулировать состоянием блокчейна, тестировать конкретные операции отката и
          события. Foundry предоставляет разработчикам эту возможность с помощью чит-кодов, делая тестирование более
          полным и точным.</p>
        <p>Чит-коды позволяют разработчикам выполнять ряд нестандартных операций, таких как изменение номеров блоков или
          идентичности вызывающего. Эти функции реализуются путём вызова определённых функций по определённому адресу
          (0x7109709ECfa91a80626fF3989D68f67F5b1DD12D). В контракте Test стандартной библиотеки Forge доступ к чит-кодам
          осуществляется через экземпляр виртуальной машины.</p>
        <h3>Переключение идентичности: vm.prank</h3>
        <p>При проведении тестов, связанных с разрешениями, часто возникает необходимость имитировать поведение разных
          пользователей. С помощью функции vm.prank мы можем временно изменить идентичность вызывающего. Например, при
          тестировании функции, вызов которой разрешён только владельцу контракта, мы можем использовать vm.prank для
          имитации попытки вызова от лица, не являющегося владельцем.</p>
        <code><pre>pragma solidity 0.8.10;

import "forge-std/Test.sol";

contract OwnerUpOnlyTest is Test {
    OwnerUpOnly upOnly;

    function setUp() public {
        upOnly = new OwnerUpOnly();
    }

    function testFail_IncrementAsNotOwner() public {
        vm.prank(address(0));
        upOnly.increment();
    }
}</pre></code>
        <h3>Ожидание отката: vm.expectRevert</h3>
        <p>Проверка корректности отката контракта при определённых условиях является важной частью проверки
          безопасности контракта. vm.expectRevert позволяет указать конкретный тип ошибки или сообщение об ошибке,
          а затем выполнить операцию, которая может вызвать эту ошибку. Если откат контракта происходит ожидаемым
          образом, тест пройден.</p>
        <code><pre>contract OwnerUpOnlyTest is Test {
    OwnerUpOnly upOnly;

    // ...

    function test_RevertWhen_CallerIsNotOwner() public {
        vm.expectRevert(Unauthorized.selector);
        vm.prank(address(0));
        upOnly.increment();
    }
}</pre></code>
        <h3>Ожидание события: vm.expectEmit</h3>
        <p>События в смарт-контрактах позволяют записывать информацию в блокчейн. Проверка корректности запуска
          конкретных событий и соответствия их параметров ожиданиям критически важна для обеспечения корректности
          поведения контракта в тестах. vm.expectEmit позволяет заранее указать ожидаемые характеристики событий и
          проверяет, запускаются ли соответствующие события в операциях контракта.</p>
        <code><pre>contract EmitContractTest is Test {
    event Transfer(address indexed from, address indexed to, uint256 amount);

    function test_ExpectEmit() public {
        ExpectEmit emitter = new ExpectEmit();
        vm.expectEmit(true, true, false, true);
        emit Transfer(address(this), address(1337), 1337);
        emitter.t();
    }
}</pre></code>
        <h3>Резюме</h3>
        <p>Чит-коды предоставляют Foundry мощные возможности тестирования, позволяя разработчикам моделировать сложные
          блокчейн-среды и операции при тестировании смарт-контрактов. Используя такие чит-коды, как переключение
          идентифичности, ожидаение отката и ожидание события, разработчики могут проводить более глубокое и точное
          тестирование смарт-контрактов, гарантируя их надежность и безопасность.</p>
        <h2>Написание тестов</h2>
        <p>Тестирование — важнейший этап обеспечения безопасности и функциональности смарт-контрактов в процессе
          разработки. Использование стандартной библиотеки Forge из набора инструментов Foundry для тестирования может
          значительно упростить и ускорить этот процесс. В этом руководстве мы рассмотрим, как писать тесты с
          использованием тестового контракта Forge, включая базовое тестирование, расширенные функции и использование
          общих настроек.</p>
        <h3>Введение в тестирование с помощью Foundry</h3>
        <p>Foundry предоставляет мощные возможности для тестирования смарт-контрактов Ethereum. Используя тестовый
          контракт в стандартной библиотеке Forge, разработчики могут использовать ряд расширенных функций и чит-кодов
          для моделирования различных состояний блокчейна и поведения транзакций.</p>
        <h3>Базовое использование</h3>
        <p>Сначала импортируйте библиотеку forge-std/Test.sol и сделайте так, чтобы контракт тестирования наследовал от
          Test:</p>
        <code><pre>pragma solidity 0.8.10;

import "forge-std/Test.sol";

contract MyTest is Test {
    // Тестовый код
}</pre></code>
        <p>Таким образом, тестовый контракт может получить доступ к методам утверждения, функциям журналирования,
          чит-кодам и другим функциям, предоставляемым контрактом Test.</p>
        <h3>Ключевые слова тестирования</h3>
        <ul>
          <li>Функция setUp — необязательная функция, которая вызывается перед запуском тестового случая и используется
            для инициализации среды тестирования:</li>
          <code><pre>function setUp() public {
    // Код инициализации
}</pre></code>
          <li>Тестовый случай — функция с префиксом test, — распознанается как тестовый случай и выполняется:</li>
          <code><pre>function test_MyFunctionality() public {
    // Логика тестирования
}</pre></code>
          <li>Функция testFail — В отличие от префикса test, testFail используется для обозначения ожидаемого провала
            теста. Если эта функция не запускает откат, тест считается проваленным:</li>
          <code><pre>function testFail_MyFailingCase() public {
    // Тестовая логика, которая, как ожидается, потерпит неудачу
}</pre></code>
        </ul>
        <h3>Расширенные методы тестирования</h3>
        <ul>
          <li>Точная обработка ошибок с помощью expectRevert — чит-код expectRevert позволяет предвидеть определенные
            ошибки, повышая точность и читаемость тестов:</li>
          <code><pre>function test_MyRevertCase() public {
    vm.expectRevert(SomeError.selector);
    // Может вызвать ошибку SomeError
}</pre></code>
          <li>Развертыватель контрактов в тестировании — контракты, развернутые в тестах, будут развернуты по
            определенному адресу (например, 0xb4c79daB8f259C7Aee6E5b2Aa729821864227e84), что полезно для тестирования
            определенных разрешений (например, onlyOwner).</li>
          <li>Использование общих настроек — создавая абстрактные контракты и наследуя их в тестовых контрактах, можно
            обмениваться настройками:</li>
          <code><pre>abstract contract SetupHelper {
    // Общие коды настройки
}

contract MyTest is Test, SetupHelper {
    function setUp() public {
        // Общая настройка
    }
}</pre></code>
        </ul>
        <h3>Примечания</h3>
        <ul>
          <li>Тестовые функции должны быть объявлены как external или public.</li>
          <li>Использование общих настроек позволяет избежать повторения одного и того же кода инициализации в каждом
            тестовом контракте, что повышает возможность повторного использования кода и удобство его обслуживания.</li>
        </ul>
        <p>Следуя приведенным выше рекомендациям, разработчики могут эффективно писать и выполнять тесты
          смарт-контрактов с использованием стандартной библиотеки Forge, гарантируя качество и безопасность контрактов.
        </p>
        <h2>Выполнение тестов</h2>
        <h3>Базовый запуск тестов</h3>
        <p>Используя команду forge test мы можем запустить все тесты в проекте. Forge автоматически ищет все тестовые
          контракты в каталоге исходного кода и выполняет функции с префиксом test. По умолчанию тестовые файлы обычно
          размещаются в каталоге test/ и имеют расширение .t.sol.</p>
        <p>Пример вывода выполнения forge test может выглядеть так:</p>
        <code><pre>> forge test
No files changed, compilation skipped

Ran 2 tests for test/Counter.t.sol:CounterTest
[PASS] testFuzz_SetNumber(uint256) (runs: 256, μ: 30474, ~: 31252)
[PASS] test_Increment() (gas: 31225)
Suite result: ok. 2 passed; 0 failed; 0 skipped; finished in 15.15ms (14.74ms CPU time)</pre></code>
        <h3>Выполнение определенных тестов</h3>
        <p>Мы можем запускать определенные тестовые случаи или контракты, следуя критериям фильтрации:</p>
        <code>> forge test --match-contract ComplicatedContractTest --match-test test_Deposit</code>
        <p>Эта команда запустит только тестовую функцию с именем test_Deposit, содержащуюся в тестовом контракте с
          именем ComplicatedContractTest.</p>
        <h3>Использование шаблонов поиска</h3>
        <p>Мы также можем использовать флаг --match-path для запуска тестовых файлов, которые соответствуют определенным
          шаблонам поиска:</p>
        <code>> forge test --match-path test/ContractB.t.sol</code>
        <h3>Журналирование и трассировка</h3>
        <p>По умолчанию тесты Forge отображают только сводную информацию о тестах. Мы можем управлять объёмом
          отображаемой информации, увеличивая уровень детализации (с помощью флага -v).</p>
        <ul>
          <li>Уровень 2 (vv): отображает журналы, созданные во время тестирования, включая ошибки утверждений,
            показывая ожидаемую и фактическую информацию.</li>
          <li>Уровень 3 (vvv): для неудачных тестов также отображаются трассировки стека.</li>
          <li>Уровень 4 (vvvv): отображает трассировки стека для всех тестов и трассировки установки для неудачных
            тестов.</li>
          <li>Уровень 5 (vvvvv): всегда отображает трассировки стека и трассировки установки.</li>
        </ul>
        <h3>Режим слежения</h3>
        <p>При использовании команды forge test --watch Forge будет повторно запускать тесты по мере внесения изменений
          в файлы.</p>
        <p>По умолчанию перезапускаются только изменённые тестовые файлы. Если нужно перезапускать все тесты после
          каждого изменения, можно использовать команду forge test --watch --run-all.</p>
        <h3>Резюме</h3>
        <p>Инструменты тестирования Forge от Foundry предоставляют разработчикам смарт-контрактов мощную и гибкую среду
          тестирования. Благодаря точной фильтрации тестов, подробному журналированию и трассировке, а также удобному
          режиму слежения, разработчики могут эффективно отлаживать и улучшать код смарт-контрактов. Используя Forge, мы
          можем гарантировать качество и безопасность смарт-контрактов, закладывая прочную основу для разработки
          блокчейн-приложений.</p>
        <h2>Анализ трассировок выполнения тестов</h2>
        <p>При использовании Foundry для тестирования смарт-контрактов понимание и анализ трассировок выполнения тестов
          критически важны для оценки влияния вызовов и взаимодействий контрактов. Цель этого урока — помочь
          разработчикам разобраться в трассировках выполнения тестов, включая их формат, цветовую кодировку и
          интерпретацию информации в трассировках.</p>
        <h3>Формат трассировки выполнения теста</h3>
        <p>Трассировки выполнения тестов Foundry имеют иерархическую структуру, наглядно отображающую цепочку вызовов
          контракта и результаты каждого вызова. Основной формат следующий:</p>
        <code><pre>[&lt;Gas Usage&gt;] &lt;Contract&gt;::&lt;Function&gt;(&lt;Parameters&gt;)
  ├─ [&lt;Gas Usage&gt;] &lt;Contract&gt;::&lt;Function&gt;(&lt;Parameters&gt;)
  │   └─  &lt;Return Value&gt;
  └─  &lt;Return Value&gt;</pre></code>
        <ul>
          <li>&lt;Gas Usage&gt;: общий расход газа за весь вызов функции отображается в квадратных скобках.</li>
          <li>&lt;Contract&gt;::&lt;Function&gt;: имя контракта и имя вызываемой функции.</li>
          <li>&lt;Parameters&gt;: параметры, передаваемые в вызов функции.</li>
          <li>&lt;Return Value&gt;: возвращаемое значение вызова функции.</li>
        </ul>
        <p>Каждая трассировка выполнения может содержать несколько подтрассировок, при этом каждая подтрассировка
          представляет собой вызов контракта и его возвращаемое значение.</p>
        <h3>Цветовое кодирование</h3>
        <p>Если ваш терминал поддерживает цветной дисплей, трассировки выполнения тестов Foundry используют разные цвета
          для различения типов вызовов:</p>
        <ul>
          <li>Зеленый: вызовы, которые не привели к отмене.</li>
          <li>Красный: вызовы, которые привели к отмене.</li>
          <li>Синий: вызовы чит-кодов.</li>
          <li>Голубой: выброшенные журналы.</li>
          <li>Желтый: развертывание контрактов.</li>
        </ul>
        <p>Эти цветовые коды помогают разработчикам быстро идентифицировать ключевую информацию в процессе тестирования.
        </p>
        <h3>Проблемы несоответствия потребления газа</h3>
        <p>Иногда может возникнуть ситуация, когда расход газа вызовом не полностью совпадает с суммой расхода
          газа всеми его подвызовами. Это может произойти из-за дополнительных операций, выполняемых между вызовами,
          таких как арифметические операции и операции чтения/записи данных из хранилища. Например:</p>
        <code><sub>[24661] OwnerUpOnlyTest::testIncrementAsOwner()
  ├─ [2262] OwnerUpOnly::count()
  │   └─   0
  ├─ [20398] OwnerUpOnly::increment()
  │ └─   ()
  ├─ [262] OwnerUpOnly::count()
  │ └─   1
  └─   ()</sub></code>
        <p>В этом примере общий расход газа для вызова testIncrementAsOwner составляет 24661, но сумма расходов газа
          для его подвызовов не равна этому значению. Это расхождение обусловлено дополнительными операциями,
          выполняемыми между подвызовами.</p>
        <h3>Декодированные и недекодированные трассировки выполнения</h3>
        <p>Foundry старается декодировать сигнатуры и значения, когда это возможно. Однако в некоторых случаях, когда
          декодирование невозможно, трассировка отображается в следующем формате:</p>
        <code><pre>[&lt;Gas Usage&gt;] &lt;Address&gt;::&lt;Calldata&gt;
  └─   &lt;Return Data&gt;</pre></code>
        <p>В этом формате &lt;Address&gt; представляет адрес вызываемого контракта, &lt;Calldata&gt; — необработанные
          данные, отправляемые функции, а &lt;Return Data&gt; — необработанные данные, возвращаемые вызовом функции. Это
          обычно происходит, когда сигнатура контракта или функции неизвестна или не зарегистрирована в тестовой среде
          Foundry.</p>
        <h3>Резюме</h3>
        <p>Понимание трассировок выполнения тестов, генерируемых Foundry, критически важно для тестирования и отладки
          смарт-контрактов. Освоив формат трассировок выполнения, цветовую кодировку и информацию о потреблении газа,
          разработчики могут более эффективно анализировать поведение контрактов, выявлять и устранять потенциальные
          проблемы.</p>
      </article>
    </section>
    <section class="main-section" id="fork-testing">
      <article>

        <header>Тестирование форков</header>
        <p>Тестирование форков — важный метод тестирования при разработке блокчейнов, особенно при разработке
          смарт-контрактов на программируемых блокчейнах, таких как Ethereum. Мы изучим два разных способа проведения
          тестирования форков с помощью инструмента Forge: режим форков и чит-коды форков.</p>
        <h2>Режим форков</h2>
        <p>Режим форка позволяет разработчикам запускать все тесты в форкнутой среде, указав RPC-URL. При использовании
          режима форка RPC-URL можно передать с помощью флага --fork-url, как показано ниже:</p>
        <code>forge test --fork-url &lt;your_rpc_url&gt;</code>
        <p>В режиме форка следующие значения будут отражать состояние цепочки на момент форка:</p>
        <ul>
          <li>block_number</li>
          <li>chain_id</li>
          <li>gas_limit</li>
          <li>gas_price</li>
          <li>block_base_fee_per_gas</li>
          <li>block_timestamp</li>
        </ul>
        <p>Чтобы выполнить форк с определенного блока, можно использовать флаг --fork-block-number:</p>
        <code>forge test --fork-url &lt;your_rpc_url&gt; --fork-block-number 1</code>
        <h3>Кэширование</h3>
        <p>Если указаны оба параметра --fork-url и --fork-block-number, данные для этого блока будут кэшированы для
          будущих тестовых запусков. Кэш находится в ~/.foundry/cache/rpc/&lt;имя цепочки&gt;/&lt;номер блока&gt;. Чтобы
          очистить кэш, можно удалить этот каталог или запустить forge clean (что удаляет все артефакты сборки и
          каталоги кэша).</p>
        <h3>Улучшенная трассировка</h3>
        <p>Forge поддерживает идентификацию контрактов в форк-среде с помощью Etherscan. Вы можете передать ключ API
          Etherscan с флагом --etherscan-api-key:</p>
        <code>forge test --fork-url &lt;your_rpc_url&gt; --etherscan-api-key &lt;your_etherscan_api_key&gt;</code>
        <h2>Чит-коды форков</h2>
        <p>Чит-коды форков позволяют программно входить в режим форков в тестовом коде Solidity. Эта техника позволяет
          разработчикам использовать режим форков для каждого теста и обрабатывать несколько форков в рамках теста. В
          этом уроке подробно описано использование чит-кодов форков, приведены примеры кода, а также рассмотрены
          характеристики разделения и постоянства хранилища.</p>
        <h3>Использование чит-кодов форков</h3>
        <p>В отличие от настройки режима форка с помощью параметров Forge CLI, чит-коды форка позволяют создавать,
          выбирать и управлять несколькими форками непосредственно в тестовом коде Solidity. Каждый форк
          идентифицируется уникальным идентификатором uint256.</p>
        <h3>Изоляция тестовых функций</h3>
        <p>Важно отметить, что все тестовые функции изолированы, то есть каждая тестовая функция запускается в копии
          состояния после setUp и выполняется в своей собственной изолированной EVM. Поэтому форки, созданные во время
          setUp, доступны в тестах.</p>
        <h3>Примеры создания и выбора форков</h3>
        <p>Следующий пример демонстрирует, как создавать и выбирать форки с помощью чит-кодов форков в тестовом
          контракте.</p>
        <h3>Определение идентификаторов форков</h3>
        <code><pre>contract ForkTest is Test {
    uint256 mainnetFork;
    uint256 optimismFork;
}</pre></code>
        <p>В контракте ForkTest мы сначала определяем две переменные mainnetFork и optimismFork для хранения
          идентификаторов форков сети mainnet и Optimism.</p>
        <h3>Создание форка</h3>
        <code><pre>function setUp() public {
    mainnetFork = vm.createFork(MAINNET_RPC_URL);
    optimismFork = vm.createFork(OPTIMISM_RPC_URL);
}</pre></code>
        <h3>Выбор форка</h3>
        <code><pre>function testCanSelectFork() public {
    vm.selectFork(mainnetFork);
    assertEq(vm.activeFork(), mainnetFork);
}</pre></code>
        <p>С помощью метода vm.selectFork мы выбираем и активируем определенную ветвь, а затем проверяем корректность
          текущей активированной ветви с помощью vm.activeFork().</p>
        <h3>Независимость и устойчивость форков</h3>
        <p>Каждый форк работает как независимый EVM с собственным отдельным хранилищем. msg.sender и состояние самого
          тестового контракта сохраняются во всех форках. Другими словами, любые изменения, внесенные во время
          активности форка A, записываются только в хранилище форка A и недоступны при выборе другого форка.</p>
        <h3>Пример создания нового контракта</h3>
        <code><pre>function testCreateContract() public {
    vm.selectFork(mainnetFork);
    SimpleStorageContract simple = new SimpleStorageContract();
    simple.set(100);
    assertEq(simple.value(), 100);
    vm.selectFork(optimismFork);
    // Попытка доступа к simple.value() здесь завершится неудачей, поскольку simple существует только в mainnetFork.
}</pre></code>
        <p>В этом примере показан процесс создания нового контракта на активной ветке. При переходе с одной ветки на
          другую доступ между ветками имеют только те учетные записи и контракты, которые помечены как постоянные.</p>
        <h3>Создание постоянных контрактов</h3>
        <p>При тестировании смарт-контрактов, особенно в разных средах форков блокчейна, концепция постоянных учетных
          записей (или контрактов) становится крайне важной. Постоянные учетные записи позволяют нам создавать и
          изменять состояние в одной среде форка и сохранять это состояние неизменным в другой. Следующий пример кода
          иллюстрирует, как создать постоянный контракт и использовать его в разных средах форков:</p>
        <code><pre>contract SimpleStorageContract {
    uint256 public value;

    function set(uint256 _value) public {
        value = _value;
    }
}

// Тестирование создания постоянных контрактов 
function testCreatePersistentContract() public {
    // Сначала выбираем среду форка
    vm.selectFork(mainnetFork);
    // Развеорачиваеь и инициализируем контракт в выбранной среде
    SimpleStorageContract simple = new SimpleStorageContract();
    simple.set(100);
    // Убеждаемся, что статус контракта установлен правильно
    assertEq(simple.value(), 100);

    // Затем помечаем контракт как постоянный
    vm.makePersistent(address(simple));
    // Убеждаемся, что контракт был правильно помечен как постоянный
    assert(vm.isPersistent(address(simple)));

    // Затем переключаемся на среду другого форка
    vm.selectFork(optimismFork);
    // Убеждаемся, что контракт по-прежнему помечен как постоянный даже в среде нового форка
    assert(vm.isPersistent(address(simple)));

    // Наконец, убеждаемся, что состояние постоянного контракта остается неизменным в среде нового форка
    assertEq(simple.value(), 100);
}</pre></code>
        <p>С помощью метода vm.makePersistent(address) мы помечаем простой контракт как постоянный, гарантируя, что его
          состояние (в данном примере — значение, установленное методом set) остается неизменным в средах разных форков.
          Затем мы проверяем, правильно ли контракт помечен как постоянный, вызывая vm.isPersistent(address). При
          переходе в среду другого форка (например, Optimism fork) мы подтверждаем, что контракт по-прежнему сохраняет
          свое постоянное состояние и сохраненное значение, повторно вызывая vm.isPersistent(address) и
          assertEq(simple.value(), 100).</p>
        <p>Эта возможность особенно важна, поскольку позволяет разработчикам тестировать поведение и взаимодействие
          контрактов в средах нескольких форков без необходимости повторного развертывания или переинициализации
          состояний контрактов, тем самым повышая эффективность и результативность тестирования.
        </p>
      </article>
    </section>
    <section class="main-section" id="fuzz-testing">
      <article>
        <header>Фаззинг-тестирование смарт-контрактов</header>
        <p>Фаззинг-тестирование — это автоматизированный метод тестирования программного обеспечения, который тестирует
          программы, генерируя большие объёмы случайных входных данных. В разработке смарт-контрактов
          фаззинг-тестирование используется для выявления потенциальных уязвимостей и аномального поведения в
          контрактах. В этом уроке мы рассмотрим, как проводить фаззинг-тестирование смарт-контрактов.</p>
        <h2>Настройка среды тестирования</h2>
        <p>Сначала необходимо установить и настроить среду Foundry. Затем создайте проект смарт-контракта Solidity и
          напишите код контракта и тестовые файлы. Например, вот простой контракт Safe, который реализует функции
          депозита и снятия средств:</p>
        <code><pre>pragma solidity 0.8.10;

contract Safe {
    receive() external payable {}

    function withdraw() external {
        payable(msg.sender).transfer(address(this).balance);
    }
}</pre></code>
        <h2>Модульное тестирование и тестирование свойств</h2>
        <h3>Модульное тестирование</h3>
        <p>Модульное тестирование сосредоточено на тестировании конкретных функций в коде. Создавая тестовые случаи, вы
          можете проверить, ведет ли себя код ожидаемым образом в заданных условиях.</p>
        <code><pre>import "forge-std/Test.sol";

contract SafeTest is Test {
    Safe safe;

    function setUp() public {
        safe = new Safe();
    }

    function test_Withdraw() public {
        payable(address(safe)).transfer(1 ether);
        uint256 preBalance = address(this).balance;
        safe.withdraw();
        uint256 postBalance = address(this).balance;
        assertEq(preBalance + 1 ether, postBalance);
    }
}</pre></code>
        <h3>Тестирование свойств</h3>
        <p>В отличие от модульного тестирования, тестирование свойств не проверяет конкретные входные и выходные данные,
          а проверяет общие свойства или поведение. Тестирование свойств включает в себя генерацию большого количества
          случайных входных данных, чтобы убедиться, что код ведет себя ожидаемым образом в различных условиях.</p>
        <h3>Переход к тестированию свойств</h3>
        <p>В Foundry любая тестовая функция с параметрами считается тестом свойств. Измените тестовые функции в
          контракте SafeTest, чтобы представить фаззинг-тестирование.</p>
        <code><pre>function testFuzz_Withdraw(uint256 amount) public {
    payable(address(safe)).transfer(amount);
    uint256 preBalance = address(this).balance;
    safe.withdraw();
    uint256 postBalance = address(this).balance;
    assertEq(preBalance + amount, postBalance);
}</pre></code>
        <h3>Обработка больших значений</h3>
        <p>Во время фаззинг-тестирования могут возникнуть ситуации, когда ввод больших значений приводит к сбоям в
          тестировании. Например, если сумма превышает баланс, принадлежащий контракту, тест завершится сбоем. Чтобы
          решить эту проблему, можно ограничить тип суммы uint96, чтобы гарантировать, что вводимые значения
          находятся в разумном диапазоне.</p>
        <code><pre>function testFuzz_Withdraw(uint96 amount) public {
    // Логика тестирования...
}</pre></code>
        <h3>Исключение особых случаев</h3>
        <p>Используя чит-код vm.assume, вы можете исключить определенные случаи, которые не хотите тестировать.
          Например, если вы не хотите тестировать выводы ниже 0,1 ETH, вы можете написать следующее:</p>
        <code><pre>function testFuzz_Withdraw(uint96 amount) public {
    vm.assume(amount > 0.1 ether);
    // Логика тестирования...
}</pre></code>
        <h3>Интерпретация результатов теста</h3>
        <p>Результаты фаззинг-тестирования предоставляют несколько ключевых сведений:</p>
        <ul>
          <li>runs: количество раз, когда тест был запущен. По умолчанию, фаззинг-тестирование генерирует 256 сценариев;
          </li>
          <li>μ: среднее потребление газа за все запуски фаззинга;</li>
          <li>~ (тильда): среднее потребление газа во всех запусках фаззинга.</li>
        </ul>
        <p>Наблюдая за этими показателями, вы можете лучше понять поведение и производительность контракта при различных
          входных данных.</p>
        <h3>Преимущества фаззинг-тестирования</h3>
        <ul>
          <li>Автоматическое тестирование: благодаря автоматическому созданию тестовых случаев сокращается необходимость
            в ручном написании тестовых случаев, что делает процесс тестирования более эффективным и систематическим;
          </li>
          <li>Широкий охват: благодаря рандомизации входных данных, фаззинг-тестирование позволяет исследовать
            различные варианты поведения контракта, выявляя ошибки, которые могут быть упущены при обычном тестировании;
          </li>
          <li>Высокая гибкость: благодаря поддержке настройки параметров тестирования, таких как количество прогонов и
            типы ввода, фаззинг-тестирование можно настроить в соответствии с ранообразными требованиями.</li>
        </ul>
        <h3>Лучшие практики для фаззинг-тестирования</h3>
        <ul>
          <li>Определите цели тестирования: перед проведением фаззинга важно уточнить, какие атрибуты или поведение вы
            хотите протестировать, чтобы можно было разработать эффективные тестовые случаи.</li>
          <li>Установите разумные диапазоны входных данных: ограничив типы и диапазоны входных данных, можно избежать
            ненужных сбоев тестирования, что повысит целенаправленность и эффективность тестирования.</li>
          <li>Анализ результатов тестирования: тщательно анализируйте результаты фаззинга, обращая внимание не только на
            неудачные тестовые случаи, но и на потенциальные проблемы, которые могут быть скрыты в пройденных тестовых
            случаях.</li>
          <li>Сочетание с другими методами тестирования: Несмотря на то, что фаззинг-тестирование — мощный инструмент,
            оно не может охватить все сценарии тестирования. Сочетание фаззинга с другими методами тестирования, такими
            как модульное и интеграционное, позволяет более полно проверить корректность и безопасность
            смарт-контрактов.</li>
        </ul>
        <h3>Резюме</h3>
        <p>Фаззинг-тестирование — мощный инструмент, помогающий разработчикам выявлять и устранять потенциальные
          уязвимости безопасности при разработке смарт-контрактов. Автоматически генерируя большое количество случайных
          входных данных, Фаззинг-тестирование эффективно охватывает граничные условия и исключительные пути в коде,
          повышая стабильность и безопасность контрактов.</p>
      </article>
    </section>
    <section class="main-section" id="invariant-testing">
      <article>
        <header>Инвариантное тестирование</header>
        <h2>Основное применение инвариантного тестирования</h2>
        <p>Тестирование инвариантности — это мощный инструмент для выявления логических ошибок в протоколах. Он
          позволяет тестировать случайные последовательности заранее определенных вызовов функций в заранее определенных
          контрактах и проверяет набор инвариантных выражений после каждого вызова функции. Поскольку последовательности
          вызовов функций являются случайными, а входные данные — нечеткими, тестирование инвариантности может выявить
          ошибки в допущениях и логические ошибки в крайних случаях и в очень сложных состояниях протокола.</p>
        <h3>Размерности тестирования инвариантности</h3>
        <p>В тестировании инвариантности есть два измерения: прогоны и глубина:</p>
        <ul>
          <li>Прогоны: количество раз, когда генерируется и выполняется серия вызовов функций;</li>
          <li>Глубина: количество вызовов функций, выполненных в рамках данного прогона. Все определенные инварианты
            проверяются после каждого вызова функции. Если вызов функции отменяется, счетчик глубины все равно
            увеличивается.</li>
        </ul>
        <h3>Настройка выполнения тестирования инвариантности</h3>
        <p>Выполнение тестирования инвариантности управляется с помощью управляемых пользователем примитивов
          конфигурации Forge. Конфигурация может применяться глобально или для каждого набора тестов. Подробные сведения
          о глобальной конфигурации и встроенной конфигурации доступна в документации.</p>
        <h3>Определение инвариантов</h3>
        <p>Инварианты — это условия, которые должны всегда выполняться в процессе фазз-тестирования. Хороший набор
          тестов на инвариантность должен включать как можно больше инвариантов и может иметь разные наборы тестов для
          разных состояний протокола.</p>
        <h3>Примеры инвариантов</h3>
        <ul>
          <li>Для Uniswap «формула xy=k всегда верна».</li>
          <li>Для токенов ERC-20 «сумма всех балансов пользователей равна общему предложению».</li>
        </ul>
        <h3>Утверждение инвариантов</h3>
        <p>Инварианты могут быть утверждены несколькими способами:</p>
        <ul>
          <li>Прямое утверждение: запрос смарт-контракта протокола и утверждение, соответствует ли значение ожидаемому
            значению;</li>
          <li>Утверждение призрачной переменной: запрос смарт-контракта протокола и сравнение его со значением,
            сохраненным в тестовой среде (призрачная переменная);</li>
          <li>Неоптимизированное (утверждение наивной реализации): запрос смарт-контракта протокола и сравнение его с
            простой и, как правило, дорогой по газу реализацией той же логики.</li>
        </ul>
        <h3>Условные инварианты</h3>
        <p>Хотя инварианты должны оставаться верными в ходе данной деятельности по фузз-тестированию, это не означает,
          что они должны быть верными в каждом сценарии. Некоторые инварианты могут быть введены/удалены в определенных
          сценариях (например, в периоды ликвидации).</p>
        <h2>Расширенные применения тестирования инвариантности</h2>
        <h3>Настройка целевых контрактов</h3>
        <p>Целевые контракты для тестирования инвариантности могут быть установлены следующими тремя способами:</p>
        <ol>
          <li>Контракты, добавленные вручную в массив targetContracts, будут включены в набор целевых контрактов;</li>
          <li>Контракты, развернутые в функции setUp, будут автоматически добавлены в набор целевых контрактов, если
            контракты не были добавлены вручную с помощью метода 1;</li>
          <li>Контракты, развернутые в функции setUp, могут быть удалены из набора целевых контрактов, если они
            добавлены в массив excludeContracts.</li>
        </ol>
        <h3>Обработчики на основе тестов</h3>
        <p>Для более сложных и интегрированных протоколов необходимы целевые контракты с более продвинутыми стратегиями,
          чтобы достичь ожидаемых результатов. Используя обработчики в тестах, можно добавить слой между протоколом и
          фузером, чтобы обеспечить успешные вызовы функций, что позволит проводить более надежные тесты.</p>
        <h3>Тестирование с участием нескольких участников</h3>
        <p>Используя чит-код prank в forge-std, каждый обработчик может управлять группой участников и выполнять одни и
          те же вызовы функций с разных адресов msg.sender, что делает тест более близким к реальным сценариям.</p>
      </article>
    </section>
    <section class="main-section" id="differential-testing">
      <article>
        <header>Дифференциальное тестирование</header>
        <h2>Что такое дифференциальное тестирование?</h2>
        <p>Дифференциальное тестирование — это метод тестирования, который позволяет находить ошибки путем сравнения
          результатов работы нескольких реализаций одной и той же функции. Этот подход основан на простом предположении:
          если две реализации дают разные результаты при одинаковых входных данных, то по крайней мере одна из них
          содержит ошибку.</p>
        <h3>Предпосылки и принципы дифференциального тестирования</h3>
        <p>Основой дифференциального тестирования является перекрестная валидация. Например, если у нас есть
          функциональная спецификация F(X) и две реализации этой спецификации, f1(X) и f2(X), мы ожидаем, что для всех
          разумных входных данных x f1(x) должно равняться f2(x). Если f1(x) не равно f2(x), то мы знаем, что по крайней
          мере одна реализация неверна. Дифференциальное тестирование особенно полезно в следующих сценариях:</p>
        <ul>
          <li>Сравнение обновленной реализации с ее более ранней версией;</li>
          <li>Тестирование кода по отношению к известной эталонной реализации;</li>
          <li>Проверка совместимости со сторонними инструментами и зависимостями.</li>
        </ul>
        <h3>Практическое применение дифференциального тестирования</h3>
        <p>В разработке программного обеспечения, и в частности в блокчейн-разработке, дифференциальное тестирование
          может использоваться для обеспечения правильности обновлений кодовой базы, проверки согласованности алгоритмов
          и гарантии бесшовного перехода между различными версиями программного обеспечения.</p>
        <h3>Резюме</h3>
        <p>Дифференциальное тестирование — это мощный метод тестирования, который помогает разработчикам обеспечить
          надежность программного обеспечения. В этой главе вы изучили основные концепции и сценарии применения
          дифференциального тестирования. В следующих главах мы более подробно рассмотрим, как применять
          дифференциальное тестирование в реальной разработке, особенно в блокчейн-разработке и разработке
          смарт-контрактов.</p>
        <h2>Дифференциальное фузз-тестирование</h2>
        <p>Дифференциальное фузз-тестирование является расширением дифференциального тестирования, которое программно
          генерирует большое количество входных значений для выявления ошибок и пограничных случаев, которые могут быть
          пропущены при обычном тестировании. Этот метод особенно важен при работе со сложными алгоритмами или
          программным обеспечением, которое должно обрабатывать широкий спектр входных сценариев.</p>
        <h3>Основная концепция дифференциального фузз-тестирования</h3>
        <p>Дифференциальное фузз-тестирование автоматически генерирует входные данные и использует их для тестирования
          нескольких реализаций. Это не только позволяет проверить, ведут ли себя реализации так, как ожидается, но и
          выявляет проблемы, которые возникают только при определенных комбинациях данных или в экстремальных условиях.
        </p>
        <h3>Как использовать дифференциальное фузз-тестирование</h3>
        <p>Ниже приведены типичные шаги, которые необходимо выполнить при проведении дифференциального
          фузз-тестирования:</p>
        <ol>
          <li>Определение пространства входных данных: определите, на каких входных данных следует сосредоточиться;</li>
          <li>Генерирование входных данных: используйте инструменты фаз-тестирования для генерации широкого спектра
            случайных данных;</li>
          <li>Выполнение тестов: примените сгенерированные данные к различным реализациям;</li>
          <li>Сравнение результатов: проанализируйте результаты каждой реализации, чтобы выявить несоответствия.</li>
        </ol>
        <h3>Использование Foundry для дифференциального фузз-тестирования</h3>
        <p>Foundry предоставляет набор инструментов, которые упрощают реализацию дифференциального фузз-тестирования при
          разработке смарт-контрактов. Используя функцию ffi Foundry, мы можем вызывать внешние команды, что позволяет
          интегрировать более широкий спектр тестовых сред и фреймворков.</p>
        <h3>Пример: Дифференциальное фузз-тестирование с помощью ffi</h3>
        <p>Предположим, мы хотим проверить, совместимы ли две реализации функции. Вот простой пример тестового
          контракта:</p>
        <code><pre>import "forge-std/Test.sol";

contract DifferentialFuzzTest is Test {
    function testInputDifferentialFuzz(uint256 input) public {
        uint256 result1 = implementation1(input);
        uint256 result2 = implementation2(input);
        assertEq(result1, result2, "The outputs of the two implementations do not match");
    }

    function implementation1(uint256 input) internal pure returns (uint256) {
        return input * 2;
    }

    function implementation2(uint256 input) internal pure returns (uint256) {
        return input << 1;
    }
}</pre></code>
        <p>В этом примере implementation1 и implementation2 — две разные реализации, и тест проверяет, дают ли они
          одинаковый результат для одинакового ввода.</p>
        <h3>Резюме</h3>
        <p>В этом уроке вы изучили концепцию и основную методологию дифференциального фузз-тестирования, а также узнали,
          как использовать инструменты Foundry для реализации этого типа тестирования. Дифференциальное
          фузз-тестирование — это мощный инструмент, который может помочь разработчикам обнаружить ошибки, которые могут
          быть упущены при обычном тестировании. В следующих уроках будут представлены конкретные примеры применения,
          которые помогут вам глубже понять и научиться практическому использованию этого метода тестирования.</p>
        <h2>Практическое применение: дифференциальное тестирование реализаций дерева Меркла</h2>
        <p>В этом уроке мы рассмотрим, как использовать дифференциальное тестирование для проверки правильности
          реализации деревьев Меркла. Деревья Меркла широко используются в технологии блокчейн для эффективной проверки
          целостности блоков данных. На конкретном примере мы узнаем, как применять дифференциальное и фаззовое
          тестирование для обеспечения согласованности между различными реализациями.</p>
        <h3>Основная концепция деревьев Меркла</h3>
        <p>Дерево Меркла — это двоичное дерево, в котором каждый нелистовой узел является хешем своих дочерних узлов.
          Эта структура позволяет эффективно и безопасно проверять содержание данных и является ключевым компонентом
          технологии блокчейн.</p>
        <h3>Сценарии применения дифференциального тестирования</h3>
        <p>Проведение дифференциального тестирования нескольких реализаций гарантирует, что все реализации соответствуют
          ожидаемому поведению. Это особенно важно при разработке блокчейна, где целостность и безопасность данных имеют
          первостепенное значение.</p>
        <h3>Пример: Дифференциальное тестирование реализаций дерева Меркла</h3>
        <p>В этом примере мы сравним результаты работы алгоритмов генерации корня дерева Меркла, реализованных на двух
          разных языках (Solidity и JavaScript).</p>
        <h3>Использование Foundry и JavaScript для дифференциального тестирования</h3>
        <p>Наша цель — проверить, что функции генерации корня дерева Меркла, написанные на Solidity и JavaScript, дают
          одинаковый результат. Мы будем использовать функцию ffi Foundry для вызова внешней реализации JavaScript и
          сравнения ее результатов с реализацией Solidity.</p>
        <h3>Реализация на Solidity</h3>
        <p>Сначала мы создадим простую реализацию на Solidity, которая генерирует корень дерева Меркла:</p>
        <code><pre>function generateMerkleRoot(bytes32[] memory leaves) public pure returns (bytes32) {
    // Пример кода: Конкретные детали реализации опущены
    return keccak256(abi.encodePacked(leaves));
}</pre></code>
        <h3>Реализация на JavaScript и вызов ffi Foundry</h3>
        <p>Затем мы используем функцию ffi Foundry для вызова внешнего скрипта JavaScript, который также генерирует
          корень дерева Меркла.</p>
        <code><pre>function testMerkleRootMatchesJSImplementation(bytes32[] memory leaves) public {
    string[] memory args = new string[](3);
    args[0] = "node";
    args[1] = "./calculateMerkleRoot.js";
    // Предположим, что функциональность преобразования в шестнадцатеричную строку была реализована.
    args[2] = leaves.toHexString();
    
    bytes memory jsResult = vm.ffi(args);
    bytes32 jsMerkleRoot = abi.decode(jsResult, (bytes32));
    
    bytes32 solMerkleRoot = generateMerkleRoot(leaves);
    assertEq(solMerkleRoot, jsMerkleRoot, "Merkle roots do not match");
}</pre></code>
        <h3>Резюме</h3>
        <p>В этом уроке мы узнали, как на практике применять дифференциальное тестирование для проверки согласованности
          реализаций дерева Меркла. Сравнивая реализации на разных языках, мы можем обеспечить точность и
          согласованность алгоритма, что имеет решающее значение для разработки блокчейна. В следующем уроке мы
          углубимся в более продвинутые применения дифференциального тестирования, включая тестирование конкретных
          крайних случаев и сложных сценариев.</p>
        <h2>Расширенное приложение дифференциального тестирования</h2>
        <p>В этом уроке мы углубимся в расширенное приложение дифференциального тестирования, уделяя особое внимание
          известным крайним случаям и сложным сценариям. Этот метод тестирования имеет решающее значение для обеспечения
          устойчивости и надежности программного обеспечения, особенно при работе со сложными структурами данных и
          алгоритмами.</p>
        <h3>Важность расширенного дифференциального тестирования</h3>
        <p>Расширенное дифференциальное тестирование помогает разработчикам выявлять ошибки, которые трудно обнаружить
          при обычном тестировании. Систематически исследуя крайние случаи входного пространства, оно гарантирует, что
          программное обеспечение будет работать правильно в различных условиях.</p>
        <h3>Пример: Дифференциальное фузз-тестирование библиотеки Merkle Proof Library от OpenZeppelin</h3>
        <p>В этом примере мы продемонстрируем, как использовать дифференциальное фузз-тестирование для тестирования
          библиотеки доказательств Меркла Solidity, обеспечивая ее совместимость с другой известной реализацией.</p>
        <h3>Настройка теста</h3>
        <p>Для тестирования мы будем использовать инструмент Foundry и библиотеку контрактов OpenZeppelin. Предположим,
          что у нас есть две разные реализации доказательства Меркла: одна — наша собственная, а другая — реализация
          OpenZeppelin.</p>
        <code><pre>import "forge-std/Test.sol";
import "openzeppelin-contracts/contracts/utils/cryptography/MerkleProof.sol";

contract MerkleProofDifferentialTest is Test {
    Merkle myMerkle;
    bytes32[] public testLeaves;
    bytes32 public root;

    function setUp() public {
        testLeaves = [keccak256("Leaf1"), keccak256("Leaf2"), keccak256("Leaf3")];
        root = myMerkle.computeRoot(testLeaves);
    }

    function testMerkleProofCompatibility(bytes32[] memory _leaves, uint256 node) public {
        vm.assume(_leaves.length > 1);
        vm.assume(node < _leaves.length);

        bytes32[] memory proof=myMerkle.getProof(_leaves, node);
        bytes32 valueToProve=_leaves[node];
        bool myVerified=myMerkle.verifyProof(root, proof, valueToProve);
        bool ozVerified=MerkleProof.verify(proof, root, valueToProve);
        assertTrue(myVerified==ozVerified, "Proof verification results differ between implementations");
    }
}</pre></code>
        <h3>Выполнение теста</h3>
        <p>С помощью этого тестирования мы можем проверить, дают ли разные реализации одинаковые результаты проверки при
          вводе одних и тех же данных. Этот подход особенно полезен для криптографических алгоритмов и логики проверки
          данных, обеспечивая совместимость и согласованность между разными библиотеками.</p>
        <h3>Дифференциальное тестирование для известных крайних случаев</h3>
        <p>Дифференциальное тестирование не ограничивается случайно сгенерированными данными. Оно также применяется к
          известным крайним случаям, которые могут привести к непредсказуемому поведению алгоритмов.</p>
        <h3>Пример: тестирование крайних случаев</h3>
        <code><pre>function testKnownEdgeCases() public {
    // Assume that you have identified some specific data points that are causing the problem
    bytes32[] memory problematicLeaves = [keccak256("EdgeCase1"), keccak256("EdgeCase2")];
    root = myMerkle.computeRoot(problematicLeaves);
    for (uint i = 0; i < problematicLeaves.length; i++) {
        bytes32[] memory proof=myMerkle.getProof(problematicLeaves, i);
        bytes32 valueToProve=problematicLeaves[i];
        bool verified=myMerkle.verifyProof(root, proof, valueToProve);
        assertTrue(verified, "Failed to verify known edge case");
    }
}</pre></code>
        <h3>Резюме</h3>
        <p>В этом уроке мы узнали, как реализовать расширенное дифференциальное тестирование, включая фазз-тестирование
          для сложных сценариев и тестирование для известных крайних случаев. Освоение этих передовых техник поможет вам
          обеспечить надежность и стабильность вашего программного обеспечения в различных экстремальных и нестандартных
          условиях.</p>
      </article>
    </section>
  </main>
</body>